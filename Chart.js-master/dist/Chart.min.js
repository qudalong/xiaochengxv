var m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
    return typeof t;
} : function(t) {
    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
};

!function(t) {
    if ("object" == ("undefined" == typeof exports ? "undefined" : m(exports)) && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).Chart = t();
    }
}(function() {
    return function o(r, l, s) {
        function d(a, t) {
            if (!l[a]) {
                if (!r[a]) {
                    var e = "function" == typeof require && require;
                    if (!t && e) return e(a, !0);
                    if (u) return u(a, !0);
                    var n = new Error("Cannot find module '" + a + "'");
                    throw n.code = "MODULE_NOT_FOUND", n;
                }
                var i = l[a] = {
                    exports: {}
                };
                r[a][0].call(i.exports, function(t) {
                    var e = r[a][1][t];
                    return d(e || t);
                }, i, i.exports, o, r, l, s);
            }
            return l[a].exports;
        }
        for (var u = "function" == typeof require && require, t = 0; t < s.length; t++) d(s[t]);
        return d;
    }({
        1: [ function(t, e, a) {
            var n = t(22)();
            t(20)(n), t(16)(n), t(19)(n), t(15)(n), t(17)(n), t(18)(n), t(23)(n), t(27)(n), 
            t(25)(n), t(28)(n), t(26)(n), t(29)(n), t(24)(n), t(21)(n), t(30)(n), t(31)(n), 
            t(32)(n), t(33)(n), t(34)(n), t(42)(n), t(40)(n), t(41)(n), t(43)(n), t(44)(n), 
            t(9)(n), t(10)(n), t(11)(n), t(12)(n), t(13)(n), t(14)(n), t(2)(n), t(3)(n), t(4)(n), 
            t(5)(n), t(6)(n), t(7)(n), t(8)(n), n = e.exports = n;
        }, {
            10: 10,
            11: 11,
            12: 12,
            13: 13,
            14: 14,
            15: 15,
            16: 16,
            17: 17,
            18: 18,
            19: 19,
            2: 2,
            20: 20,
            21: 21,
            22: 22,
            23: 23,
            24: 24,
            25: 25,
            26: 26,
            27: 27,
            28: 28,
            29: 29,
            3: 3,
            30: 30,
            31: 31,
            32: 32,
            33: 33,
            34: 34,
            4: 4,
            40: 40,
            41: 41,
            42: 42,
            43: 43,
            44: 44,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9
        } ],
        2: [ function(t, e, a) {
            e.exports = function(a) {
                a.Bar = function(t, e) {
                    return e.type = "bar", new a(t, e);
                };
            };
        }, {} ],
        3: [ function(t, e, a) {
            e.exports = function(a) {
                a.Bubble = function(t, e) {
                    return e.type = "bubble", new a(t, e);
                };
            };
        }, {} ],
        4: [ function(t, e, a) {
            e.exports = function(a) {
                a.Doughnut = function(t, e) {
                    return e.type = "doughnut", new a(t, e);
                };
            };
        }, {} ],
        5: [ function(t, e, a) {
            e.exports = function(a) {
                a.Line = function(t, e) {
                    return e.type = "line", new a(t, e);
                };
            };
        }, {} ],
        6: [ function(t, e, a) {
            e.exports = function(a) {
                a.PolarArea = function(t, e) {
                    return e.type = "polarArea", new a(t, e);
                };
            };
        }, {} ],
        7: [ function(t, e, a) {
            e.exports = function(a) {
                a.Radar = function(t, e) {
                    return e.type = "radar", new a(t, e);
                };
            };
        }, {} ],
        8: [ function(t, e, a) {
            e.exports = function(a) {
                a.defaults.scatter = {
                    hover: {
                        mode: "single"
                    },
                    scales: {
                        xAxes: [ {
                            type: "linear",
                            position: "bottom",
                            id: "x-axis-1"
                        } ],
                        yAxes: [ {
                            type: "linear",
                            position: "left",
                            id: "y-axis-1"
                        } ]
                    },
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(t) {
                                return "(" + t.xLabel + ", " + t.yLabel + ")";
                            }
                        }
                    }
                }, a.controllers.scatter = a.controllers.line, a.Scatter = function(t, e) {
                    return e.type = "scatter", new a(t, e);
                };
            };
        }, {} ],
        9: [ function(t, e, a) {
            e.exports = function(a) {
                var h = a.helpers;
                a.defaults.bar = {
                    hover: {
                        mode: "label"
                    },
                    scales: {
                        xAxes: [ {
                            type: "category",
                            categoryPercentage: .8,
                            barPercentage: .9,
                            gridLines: {
                                offsetGridLines: !0
                            }
                        } ],
                        yAxes: [ {
                            type: "linear"
                        } ]
                    }
                }, a.controllers.bar = a.DatasetController.extend({
                    dataElementType: a.elements.Rectangle,
                    initialize: function(t, e) {
                        a.DatasetController.prototype.initialize.call(this, t, e), this.getMeta().bar = !0;
                    },
                    getBarCount: function() {
                        var a = this, n = 0;
                        return h.each(a.chart.data.datasets, function(t, e) {
                            a.chart.getDatasetMeta(e).bar && a.chart.isDatasetVisible(e) && ++n;
                        }, a), n;
                    },
                    update: function(a) {
                        var n = this;
                        h.each(n.getMeta().data, function(t, e) {
                            n.updateElement(t, e, a);
                        }, n);
                    },
                    updateElement: function(t, e, a) {
                        var n = this, i = n.getMeta(), o = n.getScaleForId(i.xAxisID), r = n.getScaleForId(i.yAxisID), l = r.getBasePixel(), s = n.chart.options.elements.rectangle, d = t.custom || {}, u = n.getDataset();
                        t._xScale = o, t._yScale = r, t._datasetIndex = n.index, t._index = e;
                        var c = n.getRuler(e);
                        t._model = {
                            x: n.calculateBarX(e, n.index, c),
                            y: a ? l : n.calculateBarY(e, n.index),
                            label: n.chart.data.labels[e],
                            datasetLabel: u.label,
                            base: a ? l : n.calculateBarBase(n.index, e),
                            width: n.calculateBarWidth(c),
                            backgroundColor: d.backgroundColor ? d.backgroundColor : h.getValueAtIndexOrDefault(u.backgroundColor, e, s.backgroundColor),
                            borderSkipped: d.borderSkipped ? d.borderSkipped : s.borderSkipped,
                            borderColor: d.borderColor ? d.borderColor : h.getValueAtIndexOrDefault(u.borderColor, e, s.borderColor),
                            borderWidth: d.borderWidth ? d.borderWidth : h.getValueAtIndexOrDefault(u.borderWidth, e, s.borderWidth)
                        }, t.pivot();
                    },
                    calculateBarBase: function(t, e) {
                        var a = this.getMeta(), n = this.getScaleForId(a.yAxisID), i = 0;
                        if (n.options.stacked) {
                            for (var o = this.chart, r = o.data.datasets, l = Number(r[t].data[e]), s = 0; s < t; s++) {
                                var d = r[s], u = o.getDatasetMeta(s);
                                if (u.bar && u.yAxisID === n.id && o.isDatasetVisible(s)) {
                                    var c = Number(d.data[e]);
                                    i += l < 0 ? Math.min(c, 0) : Math.max(c, 0);
                                }
                            }
                            return n.getPixelForValue(i);
                        }
                        return n.getBasePixel();
                    },
                    getRuler: function(t) {
                        var e, a = this, n = a.getMeta(), i = a.getScaleForId(n.xAxisID), o = a.getBarCount(), r = (e = "category" === i.options.type ? i.getPixelForTick(t + 1) - i.getPixelForTick(t) : i.width / i.ticks.length) * i.options.categoryPercentage, l = (e - e * i.options.categoryPercentage) / 2, s = r / o;
                        i.ticks.length !== a.chart.data.labels.length && (s *= i.ticks.length / a.chart.data.labels.length);
                        return {
                            datasetCount: o,
                            tickWidth: e,
                            categoryWidth: r,
                            categorySpacing: l,
                            fullBarWidth: s,
                            barWidth: s * i.options.barPercentage,
                            barSpacing: s - s * i.options.barPercentage
                        };
                    },
                    calculateBarWidth: function(t) {
                        var e = this.getScaleForId(this.getMeta().xAxisID);
                        return e.options.barThickness ? e.options.barThickness : e.options.stacked ? t.categoryWidth : t.barWidth;
                    },
                    getBarIndex: function(t) {
                        var e, a = 0;
                        for (e = 0; e < t; ++e) this.chart.getDatasetMeta(e).bar && this.chart.isDatasetVisible(e) && ++a;
                        return a;
                    },
                    calculateBarX: function(t, e, a) {
                        var n = this, i = n.getMeta(), o = n.getScaleForId(i.xAxisID), r = n.getBarIndex(e), l = o.getPixelForValue(null, t, e, n.chart.isCombo);
                        return l -= n.chart.isCombo ? a.tickWidth / 2 : 0, o.options.stacked ? l + a.categoryWidth / 2 + a.categorySpacing : l + a.barWidth / 2 + a.categorySpacing + a.barWidth * r + a.barSpacing / 2 + a.barSpacing * r;
                    },
                    calculateBarY: function(t, e) {
                        var a = this, n = a.getMeta(), i = a.getScaleForId(n.yAxisID), o = Number(a.getDataset().data[t]);
                        if (i.options.stacked) {
                            for (var r = 0, l = 0, s = 0; s < e; s++) {
                                var d = a.chart.data.datasets[s], u = a.chart.getDatasetMeta(s);
                                if (u.bar && u.yAxisID === i.id && a.chart.isDatasetVisible(s)) {
                                    var c = Number(d.data[t]);
                                    c < 0 ? l += c || 0 : r += c || 0;
                                }
                            }
                            return o < 0 ? i.getPixelForValue(l + o) : i.getPixelForValue(r + o);
                        }
                        return i.getPixelForValue(o);
                    },
                    draw: function(t) {
                        var e, a, n = t || 1, i = this.getMeta().data, o = this.getDataset();
                        for (e = 0, a = i.length; e < a; ++e) {
                            var r = o.data[e];
                            null == r || isNaN(r) || i[e].transition(n).draw();
                        }
                    },
                    setHoverStyle: function(t) {
                        var e = this.chart.data.datasets[t._datasetIndex], a = t._index, n = t.custom || {}, i = t._model;
                        i.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : h.getValueAtIndexOrDefault(e.hoverBackgroundColor, a, h.getHoverColor(i.backgroundColor)), 
                        i.borderColor = n.hoverBorderColor ? n.hoverBorderColor : h.getValueAtIndexOrDefault(e.hoverBorderColor, a, h.getHoverColor(i.borderColor)), 
                        i.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : h.getValueAtIndexOrDefault(e.hoverBorderWidth, a, i.borderWidth);
                    },
                    removeHoverStyle: function(t) {
                        var e = this.chart.data.datasets[t._datasetIndex], a = t._index, n = t.custom || {}, i = t._model, o = this.chart.options.elements.rectangle;
                        i.backgroundColor = n.backgroundColor ? n.backgroundColor : h.getValueAtIndexOrDefault(e.backgroundColor, a, o.backgroundColor), 
                        i.borderColor = n.borderColor ? n.borderColor : h.getValueAtIndexOrDefault(e.borderColor, a, o.borderColor), 
                        i.borderWidth = n.borderWidth ? n.borderWidth : h.getValueAtIndexOrDefault(e.borderWidth, a, o.borderWidth);
                    }
                }), a.defaults.horizontalBar = {
                    hover: {
                        mode: "label"
                    },
                    scales: {
                        xAxes: [ {
                            type: "linear",
                            position: "bottom"
                        } ],
                        yAxes: [ {
                            position: "left",
                            type: "category",
                            categoryPercentage: .8,
                            barPercentage: .9,
                            gridLines: {
                                offsetGridLines: !0
                            }
                        } ]
                    },
                    elements: {
                        rectangle: {
                            borderSkipped: "left"
                        }
                    },
                    tooltips: {
                        callbacks: {
                            title: function(t, e) {
                                var a = "";
                                return 0 < t.length && (t[0].yLabel ? a = t[0].yLabel : 0 < e.labels.length && t[0].index < e.labels.length && (a = e.labels[t[0].index])), 
                                a;
                            },
                            label: function(t, e) {
                                return (e.datasets[t.datasetIndex].label || "") + ": " + t.xLabel;
                            }
                        }
                    }
                }, a.controllers.horizontalBar = a.controllers.bar.extend({
                    updateElement: function(t, e, a) {
                        var n = this, i = n.getMeta(), o = n.getScaleForId(i.xAxisID), r = n.getScaleForId(i.yAxisID), l = o.getBasePixel(), s = t.custom || {}, d = n.getDataset(), u = n.chart.options.elements.rectangle;
                        t._xScale = o, t._yScale = r, t._datasetIndex = n.index, t._index = e;
                        var c = n.getRuler(e);
                        t._model = {
                            x: a ? l : n.calculateBarX(e, n.index),
                            y: n.calculateBarY(e, n.index, c),
                            label: n.chart.data.labels[e],
                            datasetLabel: d.label,
                            base: a ? l : n.calculateBarBase(n.index, e),
                            height: n.calculateBarHeight(c),
                            backgroundColor: s.backgroundColor ? s.backgroundColor : h.getValueAtIndexOrDefault(d.backgroundColor, e, u.backgroundColor),
                            borderSkipped: s.borderSkipped ? s.borderSkipped : u.borderSkipped,
                            borderColor: s.borderColor ? s.borderColor : h.getValueAtIndexOrDefault(d.borderColor, e, u.borderColor),
                            borderWidth: s.borderWidth ? s.borderWidth : h.getValueAtIndexOrDefault(d.borderWidth, e, u.borderWidth)
                        }, t.draw = function() {
                            function t(t) {
                                return s[(d + t) % 4];
                            }
                            var e = this._chart.ctx, a = this._view, n = a.height / 2, i = a.y - n, o = a.y + n, r = a.base - (a.base - a.x), l = a.borderWidth / 2;
                            a.borderWidth && (i += l, o -= l, r += l), e.beginPath(), e.setFillStyle(a.backgroundColor), 
                            e.setStrokeStyle(a.borderColor), e.setLineWidth(a.borderWidth);
                            var s = [ [ a.base, o ], [ a.base, i ], [ r, i ], [ r, o ] ], d = [ "bottom", "left", "top", "right" ].indexOf(a.borderSkipped, 0);
                            -1 === d && (d = 0), e.moveTo.apply(e, t(0));
                            for (var u = 1; u < 4; u++) e.lineTo.apply(e, t(u));
                            e.fill(), a.borderWidth && e.stroke();
                        }, t.pivot();
                    },
                    calculateBarBase: function(t, e) {
                        var a = this.getMeta(), n = this.getScaleForId(a.xAxisID), i = 0;
                        if (n.options.stacked) {
                            for (var o = this.chart, r = o.data.datasets, l = Number(r[t].data[e]), s = 0; s < t; s++) {
                                var d = r[s], u = o.getDatasetMeta(s);
                                if (u.bar && u.xAxisID === n.id && o.isDatasetVisible(s)) {
                                    var c = Number(d.data[e]);
                                    i += l < 0 ? Math.min(c, 0) : Math.max(c, 0);
                                }
                            }
                            return n.getPixelForValue(i);
                        }
                        return n.getBasePixel();
                    },
                    getRuler: function(t) {
                        var e, a = this, n = a.getMeta(), i = a.getScaleForId(n.yAxisID), o = a.getBarCount(), r = (e = "category" === i.options.type ? i.getPixelForTick(t + 1) - i.getPixelForTick(t) : i.width / i.ticks.length) * i.options.categoryPercentage, l = (e - e * i.options.categoryPercentage) / 2, s = r / o;
                        i.ticks.length !== a.chart.data.labels.length && (s *= i.ticks.length / a.chart.data.labels.length);
                        return {
                            datasetCount: o,
                            tickHeight: e,
                            categoryHeight: r,
                            categorySpacing: l,
                            fullBarHeight: s,
                            barHeight: s * i.options.barPercentage,
                            barSpacing: s - s * i.options.barPercentage
                        };
                    },
                    calculateBarHeight: function(t) {
                        var e = this.getScaleForId(this.getMeta().yAxisID);
                        return e.options.barThickness ? e.options.barThickness : e.options.stacked ? t.categoryHeight : t.barHeight;
                    },
                    calculateBarX: function(t, e) {
                        var a = this, n = a.getMeta(), i = a.getScaleForId(n.xAxisID), o = Number(a.getDataset().data[t]);
                        if (i.options.stacked) {
                            for (var r = 0, l = 0, s = 0; s < e; s++) {
                                var d = a.chart.data.datasets[s], u = a.chart.getDatasetMeta(s);
                                if (u.bar && u.xAxisID === i.id && a.chart.isDatasetVisible(s)) {
                                    var c = Number(d.data[t]);
                                    c < 0 ? l += c || 0 : r += c || 0;
                                }
                            }
                            return o < 0 ? i.getPixelForValue(l + o) : i.getPixelForValue(r + o);
                        }
                        return i.getPixelForValue(o);
                    },
                    calculateBarY: function(t, e, a) {
                        var n = this, i = n.getMeta(), o = n.getScaleForId(i.yAxisID), r = n.getBarIndex(e), l = o.getPixelForValue(null, t, e, n.chart.isCombo);
                        return l -= n.chart.isCombo ? a.tickHeight / 2 : 0, o.options.stacked ? l + a.categoryHeight / 2 + a.categorySpacing : l + a.barHeight / 2 + a.categorySpacing + a.barHeight * r + a.barSpacing / 2 + a.barSpacing * r;
                    }
                });
            };
        }, {} ],
        10: [ function(t, e, a) {
            e.exports = function(f) {
                var g = f.helpers;
                f.defaults.bubble = {
                    hover: {
                        mode: "single"
                    },
                    scales: {
                        xAxes: [ {
                            type: "linear",
                            position: "bottom",
                            id: "x-axis-0"
                        } ],
                        yAxes: [ {
                            type: "linear",
                            position: "left",
                            id: "y-axis-0"
                        } ]
                    },
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(t, e) {
                                var a = e.datasets[t.datasetIndex].label || "", n = e.datasets[t.datasetIndex].data[t.index];
                                return a + ": (" + t.xLabel + ", " + t.yLabel + ", " + n.r + ")";
                            }
                        }
                    }
                }, f.controllers.bubble = f.DatasetController.extend({
                    dataElementType: f.elements.Point,
                    update: function(a) {
                        var n = this, t = n.getMeta().data;
                        g.each(t, function(t, e) {
                            n.updateElement(t, e, a);
                        });
                    },
                    updateElement: function(t, e, a) {
                        var n = this, i = n.getMeta(), o = n.getScaleForId(i.xAxisID), r = n.getScaleForId(i.yAxisID), l = t.custom || {}, s = n.getDataset(), d = s.data[e], u = n.chart.options.elements.point, c = n.index;
                        g.extend(t, {
                            _xScale: o,
                            _yScale: r,
                            _datasetIndex: c,
                            _index: e,
                            _model: {
                                x: a ? o.getPixelForDecimal(.5) : o.getPixelForValue("object" == (void 0 === d ? "undefined" : m(d)) ? d : NaN, e, c, n.chart.isCombo),
                                y: a ? r.getBasePixel() : r.getPixelForValue(d, e, c),
                                radius: a ? 0 : l.radius ? l.radius : n.getRadius(d),
                                hitRadius: l.hitRadius ? l.hitRadius : g.getValueAtIndexOrDefault(s.hitRadius, e, u.hitRadius)
                            }
                        }), f.DatasetController.prototype.removeHoverStyle.call(n, t, u);
                        var h = t._model;
                        h.skip = l.skip ? l.skip : isNaN(h.x) || isNaN(h.y), t.pivot();
                    },
                    getRadius: function(t) {
                        return t.r || this.chart.options.elements.point.radius;
                    },
                    setHoverStyle: function(t) {
                        f.DatasetController.prototype.setHoverStyle.call(this, t);
                        var e = this.chart.data.datasets[t._datasetIndex], a = t._index, n = t.custom || {};
                        t._model.radius = n.hoverRadius ? n.hoverRadius : g.getValueAtIndexOrDefault(e.hoverRadius, a, this.chart.options.elements.point.hoverRadius) + this.getRadius(e.data[a]);
                    },
                    removeHoverStyle: function(t) {
                        f.DatasetController.prototype.removeHoverStyle.call(this, t, this.chart.options.elements.point);
                        var e = this.chart.data.datasets[t._datasetIndex].data[t._index], a = t.custom || {};
                        t._model.radius = a.radius ? a.radius : this.getRadius(e);
                    }
                });
            };
        }, {} ],
        11: [ function(t, e, a) {
            e.exports = function(e) {
                var F = e.helpers, t = e.defaults;
                t.doughnut = {
                    animation: {
                        animateRotate: !0,
                        animateScale: !1
                    },
                    aspectRatio: 1,
                    hover: {
                        mode: "single"
                    },
                    legendCallback: function(t) {
                        var e = [];
                        e.push('<ul class="' + t.id + '-legend">');
                        var a = t.data, n = a.datasets, i = a.labels;
                        if (n.length) for (var o = 0; o < n[0].data.length; ++o) e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), 
                        i[o] && e.push(i[o]), e.push("</li>");
                        return e.push("</ul>"), e.join("");
                    },
                    legend: {
                        labels: {
                            generateLabels: function(s) {
                                var d = s.data;
                                return d.labels.length && d.datasets.length ? d.labels.map(function(t, e) {
                                    var a = s.getDatasetMeta(0), n = d.datasets[0], i = a.data[e], o = i && i.custom || {}, r = F.getValueAtIndexOrDefault, l = s.options.elements.arc;
                                    return {
                                        text: t,
                                        fillStyle: o.backgroundColor ? o.backgroundColor : r(n.backgroundColor, e, l.backgroundColor),
                                        strokeStyle: o.borderColor ? o.borderColor : r(n.borderColor, e, l.borderColor),
                                        lineWidth: o.borderWidth ? o.borderWidth : r(n.borderWidth, e, l.borderWidth),
                                        hidden: isNaN(n.data[e]) || a.data[e].hidden,
                                        index: e
                                    };
                                }) : [];
                            }
                        },
                        onClick: function(t, e) {
                            var a, n, i, o = e.index, r = this.chart;
                            for (a = 0, n = (r.data.datasets || []).length; a < n; ++a) (i = r.getDatasetMeta(a)).data[o] && (i.data[o].hidden = !i.data[o].hidden);
                            r.update();
                        }
                    },
                    cutoutPercentage: 50,
                    rotation: -.5 * Math.PI,
                    circumference: 2 * Math.PI,
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(t, e) {
                                var a = e.labels[t.index], n = ": " + e.datasets[t.datasetIndex].data[t.index];
                                return F.isArray(a) ? (a = a.slice())[0] += n : a += n, a;
                            }
                        }
                    }
                }, t.pie = F.clone(t.doughnut), F.extend(t.pie, {
                    cutoutPercentage: 0
                }), e.controllers.doughnut = e.controllers.pie = e.DatasetController.extend({
                    dataElementType: e.elements.Arc,
                    linkScales: F.noop,
                    getRingIndex: function(t) {
                        for (var e = 0, a = 0; a < t; ++a) this.chart.isDatasetVisible(a) && ++e;
                        return e;
                    },
                    update: function(a) {
                        var n = this, t = n.chart, e = t.chartArea, i = t.options, o = i.elements.arc, r = e.right - e.left - o.borderWidth, l = e.bottom - e.top - o.borderWidth, s = Math.min(r, l), d = {
                            x: 0,
                            y: 0
                        }, u = n.getMeta(), c = i.cutoutPercentage, h = i.circumference;
                        if (h < 2 * Math.PI) {
                            var f = i.rotation % (2 * Math.PI), g = (f += 2 * Math.PI * (f >= Math.PI ? -1 : f < -Math.PI ? 1 : 0)) + h, p = Math.cos(f), m = Math.sin(f), b = Math.cos(g), v = Math.sin(g), x = f <= 0 && 0 <= g || f <= 2 * Math.PI && 2 * Math.PI <= g, y = f <= .5 * Math.PI && .5 * Math.PI <= g || f <= 2.5 * Math.PI && 2.5 * Math.PI <= g, k = f <= -Math.PI && -Math.PI <= g || f <= Math.PI && Math.PI <= g, S = f <= .5 * -Math.PI && .5 * -Math.PI <= g || f <= 1.5 * Math.PI && 1.5 * Math.PI <= g, C = c / 100, w = k ? -1 : Math.min(p * (p < 0 ? 1 : C), b * (b < 0 ? 1 : C)), M = S ? -1 : Math.min(m * (m < 0 ? 1 : C), v * (v < 0 ? 1 : C)), D = x ? 1 : Math.max(p * (0 < p ? 1 : C), b * (0 < b ? 1 : C)), I = y ? 1 : Math.max(m * (0 < m ? 1 : C), v * (0 < v ? 1 : C)), P = .5 * (D - w), A = .5 * (I - M);
                            s = Math.min(r / P, l / A), d = {
                                x: -.5 * (D + w),
                                y: -.5 * (I + M)
                            };
                        }
                        t.borderWidth = n.getMaxBorderWidth(u.data), t.outerRadius = Math.max((s - t.borderWidth) / 2, 0), 
                        t.innerRadius = Math.max(c ? t.outerRadius / 100 * c : 1, 0), t.radiusLength = (t.outerRadius - t.innerRadius) / t.getVisibleDatasetCount(), 
                        t.offsetX = d.x * t.outerRadius, t.offsetY = d.y * t.outerRadius, u.total = n.calculateTotal(), 
                        n.outerRadius = t.outerRadius - t.radiusLength * n.getRingIndex(n.index), n.innerRadius = n.outerRadius - t.radiusLength, 
                        F.each(u.data, function(t, e) {
                            n.updateElement(t, e, a);
                        });
                    },
                    updateElement: function(t, e, a) {
                        var n = this, i = n.chart, o = i.chartArea, r = i.options, l = r.animation, s = (o.left + o.right) / 2, d = (o.top + o.bottom) / 2, u = r.rotation, c = r.rotation, h = n.getDataset(), f = a && l.animateRotate ? 0 : t.hidden ? 0 : n.calculateCircumference(h.data[e]) * (r.circumference / (2 * Math.PI)), g = a && l.animateScale ? 0 : n.innerRadius, p = a && l.animateScale ? 0 : n.outerRadius, m = F.getValueAtIndexOrDefault;
                        F.extend(t, {
                            _datasetIndex: n.index,
                            _index: e,
                            _model: {
                                x: s + i.offsetX,
                                y: d + i.offsetY,
                                startAngle: u,
                                endAngle: c,
                                circumference: f,
                                outerRadius: p,
                                innerRadius: g,
                                label: m(h.label, e, i.data.labels[e])
                            }
                        });
                        var b = t._model;
                        this.removeHoverStyle(t), a && l.animateRotate || (b.startAngle = 0 === e ? r.rotation : n.getMeta().data[e - 1]._model.endAngle, 
                        b.endAngle = b.startAngle + b.circumference), t.pivot();
                    },
                    removeHoverStyle: function(t) {
                        e.DatasetController.prototype.removeHoverStyle.call(this, t, this.chart.options.elements.arc);
                    },
                    calculateTotal: function() {
                        var a, n = this.getDataset(), t = this.getMeta(), i = 0;
                        return F.each(t.data, function(t, e) {
                            a = n.data[e], isNaN(a) || t.hidden || (i += Math.abs(a));
                        }), i;
                    },
                    calculateCircumference: function(t) {
                        var e = this.getMeta().total;
                        return 0 < e && !isNaN(t) ? 2 * Math.PI * (t / e) : 0;
                    },
                    getMaxBorderWidth: function(t) {
                        for (var e, a, n = 0, i = this.index, o = t.length, r = 0; r < o; r++) n = (n = n < (e = t[r]._model ? t[r]._model.borderWidth : 0) ? e : n) < (a = t[r]._chart ? t[r]._chart.config.data.datasets[i].hoverBorderWidth : 0) ? a : n;
                        return n;
                    }
                });
            };
        }, {} ],
        12: [ function(t, e, a) {
            e.exports = function(t) {
                function f(t, e) {
                    return p.getValueOrDefault(t.showLine, e.showLines);
                }
                var p = t.helpers;
                t.defaults.line = {
                    showLines: !0,
                    spanGaps: !1,
                    hover: {
                        mode: "label"
                    },
                    scales: {
                        xAxes: [ {
                            type: "category",
                            id: "x-axis-0"
                        } ],
                        yAxes: [ {
                            type: "linear",
                            id: "y-axis-0"
                        } ]
                    }
                }, t.controllers.line = t.DatasetController.extend({
                    datasetElementType: t.elements.Line,
                    dataElementType: t.elements.Point,
                    update: function(t) {
                        var e, a, n, i = this, o = i.getMeta(), r = o.dataset, l = o.data || [], s = i.chart.options, d = s.elements.line, u = i.getScaleForId(o.yAxisID), c = i.getDataset(), h = f(c, s);
                        for (h && (n = r.custom || {}, void 0 !== c.tension && void 0 === c.lineTension && (c.lineTension = c.tension), 
                        r._scale = u, r._datasetIndex = i.index, r._children = l, r._model = {
                            spanGaps: c.spanGaps ? c.spanGaps : s.spanGaps,
                            tension: n.tension ? n.tension : p.getValueOrDefault(c.lineTension, d.tension),
                            backgroundColor: n.backgroundColor ? n.backgroundColor : c.backgroundColor || d.backgroundColor,
                            borderWidth: n.borderWidth ? n.borderWidth : c.borderWidth || d.borderWidth,
                            borderColor: n.borderColor ? n.borderColor : c.borderColor || d.borderColor,
                            borderCapStyle: n.borderCapStyle ? n.borderCapStyle : c.borderCapStyle || d.borderCapStyle,
                            borderDash: n.borderDash ? n.borderDash : c.borderDash || d.borderDash,
                            borderDashOffset: n.borderDashOffset ? n.borderDashOffset : c.borderDashOffset || d.borderDashOffset,
                            borderJoinStyle: n.borderJoinStyle ? n.borderJoinStyle : c.borderJoinStyle || d.borderJoinStyle,
                            fill: n.fill ? n.fill : void 0 !== c.fill ? c.fill : d.fill,
                            steppedLine: n.steppedLine ? n.steppedLine : p.getValueOrDefault(c.steppedLine, d.stepped),
                            cubicInterpolationMode: n.cubicInterpolationMode ? n.cubicInterpolationMode : p.getValueOrDefault(c.cubicInterpolationMode, d.cubicInterpolationMode),
                            scaleTop: u.top,
                            scaleBottom: u.bottom,
                            scaleZero: u.getBasePixel()
                        }, r.pivot()), e = 0, a = l.length; e < a; ++e) i.updateElement(l[e], e, t);
                        for (h && 0 !== r._model.tension && i.updateBezierControlPoints(), e = 0, a = l.length; e < a; ++e) l[e].pivot();
                    },
                    getPointBackgroundColor: function(t, e) {
                        var a = this.chart.options.elements.point.backgroundColor, n = this.getDataset(), i = t.custom || {};
                        return i.backgroundColor ? a = i.backgroundColor : n.pointBackgroundColor ? a = p.getValueAtIndexOrDefault(n.pointBackgroundColor, e, a) : n.backgroundColor && (a = n.backgroundColor), 
                        a;
                    },
                    getPointBorderColor: function(t, e) {
                        var a = this.chart.options.elements.point.borderColor, n = this.getDataset(), i = t.custom || {};
                        return i.borderColor ? a = i.borderColor : n.pointBorderColor ? a = p.getValueAtIndexOrDefault(n.pointBorderColor, e, a) : n.borderColor && (a = n.borderColor), 
                        a;
                    },
                    getPointBorderWidth: function(t, e) {
                        var a = this.chart.options.elements.point.borderWidth, n = this.getDataset(), i = t.custom || {};
                        return i.borderWidth ? a = i.borderWidth : n.pointBorderWidth ? a = p.getValueAtIndexOrDefault(n.pointBorderWidth, e, a) : n.borderWidth && (a = n.borderWidth), 
                        a;
                    },
                    updateElement: function(t, e, a) {
                        var n, i, o = this, r = o.getMeta(), l = t.custom || {}, s = o.getDataset(), d = o.index, u = s.data[e], c = o.getScaleForId(r.yAxisID), h = o.getScaleForId(r.xAxisID), f = o.chart.options.elements.point, g = 1 === (o.chart.data.labels || []).length || 1 === s.data.length || o.chart.isCombo;
                        void 0 !== s.radius && void 0 === s.pointRadius && (s.pointRadius = s.radius), void 0 !== s.hitRadius && void 0 === s.pointHitRadius && (s.pointHitRadius = s.hitRadius), 
                        n = h.getPixelForValue("object" == (void 0 === u ? "undefined" : m(u)) ? u : NaN, e, d, g), 
                        i = a ? c.getBasePixel() : o.calculatePointY(u, e, d), t._xScale = h, t._yScale = c, 
                        t._datasetIndex = d, t._index = e, t._model = {
                            x: n,
                            y: i,
                            skip: l.skip || isNaN(n) || isNaN(i),
                            radius: l.radius || p.getValueAtIndexOrDefault(s.pointRadius, e, f.radius),
                            pointStyle: l.pointStyle || p.getValueAtIndexOrDefault(s.pointStyle, e, f.pointStyle),
                            backgroundColor: o.getPointBackgroundColor(t, e),
                            borderColor: o.getPointBorderColor(t, e),
                            borderWidth: o.getPointBorderWidth(t, e),
                            tension: r.dataset._model ? r.dataset._model.tension : 0,
                            steppedLine: !!r.dataset._model && r.dataset._model.steppedLine,
                            hitRadius: l.hitRadius || p.getValueAtIndexOrDefault(s.pointHitRadius, e, f.hitRadius)
                        };
                    },
                    calculatePointY: function(t, e, a) {
                        var n, i, o, r = this.chart, l = this.getMeta(), s = this.getScaleForId(l.yAxisID), d = 0, u = 0;
                        if (s.options.stacked) {
                            for (n = 0; n < a; n++) if (i = r.data.datasets[n], "line" === (o = r.getDatasetMeta(n)).type && o.yAxisID === s.id && r.isDatasetVisible(n)) {
                                var c = Number(s.getRightValue(i.data[e]));
                                c < 0 ? u += c || 0 : d += c || 0;
                            }
                            var h = Number(s.getRightValue(t));
                            return h < 0 ? s.getPixelForValue(u + h) : s.getPixelForValue(d + h);
                        }
                        return s.getPixelForValue(t);
                    },
                    updateBezierControlPoints: function() {
                        function t(t, e, a) {
                            return Math.max(Math.min(t, a), e);
                        }
                        var e, a, n, i, o = this.getMeta(), r = this.chart.chartArea, l = o.data || [];
                        if (o.dataset._model.spanGaps && (l = l.filter(function(t) {
                            return !t._model.skip;
                        })), "monotone" === o.dataset._model.cubicInterpolationMode) p.splineCurveMonotone(l); else for (e = 0, 
                        a = l.length; e < a; ++e) n = l[e]._model, i = p.splineCurve(p.previousItem(l, e)._model, n, p.nextItem(l, e)._model, o.dataset._model.tension), 
                        n.controlPointPreviousX = i.previous.x, n.controlPointPreviousY = i.previous.y, 
                        n.controlPointNextX = i.next.x, n.controlPointNextY = i.next.y;
                        if (this.chart.options.elements.line.capBezierPoints) for (e = 0, a = l.length; e < a; ++e) (n = l[e]._model).controlPointPreviousX = t(n.controlPointPreviousX, r.left, r.right), 
                        n.controlPointPreviousY = t(n.controlPointPreviousY, r.top, r.bottom), n.controlPointNextX = t(n.controlPointNextX, r.left, r.right), 
                        n.controlPointNextY = t(n.controlPointNextY, r.top, r.bottom);
                    },
                    draw: function(t) {
                        var e, a, n = this.getMeta(), i = n.data || [], o = t || 1;
                        for (e = 0, a = i.length; e < a; ++e) i[e].transition(o);
                        for (f(this.getDataset(), this.chart.options) && n.dataset.transition(o).draw(), 
                        e = 0, a = i.length; e < a; ++e) i[e].draw();
                    },
                    setHoverStyle: function(t) {
                        var e = this.chart.data.datasets[t._datasetIndex], a = t._index, n = t.custom || {}, i = t._model;
                        i.radius = n.hoverRadius || p.getValueAtIndexOrDefault(e.pointHoverRadius, a, this.chart.options.elements.point.hoverRadius), 
                        i.backgroundColor = n.hoverBackgroundColor || p.getValueAtIndexOrDefault(e.pointHoverBackgroundColor, a, p.getHoverColor(i.backgroundColor)), 
                        i.borderColor = n.hoverBorderColor || p.getValueAtIndexOrDefault(e.pointHoverBorderColor, a, p.getHoverColor(i.borderColor)), 
                        i.borderWidth = n.hoverBorderWidth || p.getValueAtIndexOrDefault(e.pointHoverBorderWidth, a, i.borderWidth);
                    },
                    removeHoverStyle: function(t) {
                        var e = this, a = e.chart.data.datasets[t._datasetIndex], n = t._index, i = t.custom || {}, o = t._model;
                        void 0 !== a.radius && void 0 === a.pointRadius && (a.pointRadius = a.radius), o.radius = i.radius || p.getValueAtIndexOrDefault(a.pointRadius, n, e.chart.options.elements.point.radius), 
                        o.backgroundColor = e.getPointBackgroundColor(t, n), o.borderColor = e.getPointBorderColor(t, n), 
                        o.borderWidth = e.getPointBorderWidth(t, n);
                    }
                });
            };
        }, {} ],
        13: [ function(t, e, a) {
            e.exports = function(e) {
                var S = e.helpers;
                e.defaults.polarArea = {
                    scale: {
                        type: "radialLinear",
                        lineArc: !0,
                        ticks: {
                            beginAtZero: !0
                        }
                    },
                    animation: {
                        animateRotate: !0,
                        animateScale: !0
                    },
                    startAngle: -.5 * Math.PI,
                    aspectRatio: 1,
                    legendCallback: function(t) {
                        var e = [];
                        e.push('<ul class="' + t.id + '-legend">');
                        var a = t.data, n = a.datasets, i = a.labels;
                        if (n.length) for (var o = 0; o < n[0].data.length; ++o) e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), 
                        i[o] && e.push(i[o]), e.push("</li>");
                        return e.push("</ul>"), e.join("");
                    },
                    legend: {
                        labels: {
                            generateLabels: function(l) {
                                var s = l.data;
                                return s.labels.length && s.datasets.length ? s.labels.map(function(t, e) {
                                    var a = l.getDatasetMeta(0), n = s.datasets[0], i = a.data[e].custom || {}, o = S.getValueAtIndexOrDefault, r = l.options.elements.arc;
                                    return {
                                        text: t,
                                        fillStyle: i.backgroundColor ? i.backgroundColor : o(n.backgroundColor, e, r.backgroundColor),
                                        strokeStyle: i.borderColor ? i.borderColor : o(n.borderColor, e, r.borderColor),
                                        lineWidth: i.borderWidth ? i.borderWidth : o(n.borderWidth, e, r.borderWidth),
                                        hidden: isNaN(n.data[e]) || a.data[e].hidden,
                                        index: e
                                    };
                                }) : [];
                            }
                        },
                        onClick: function(t, e) {
                            var a, n, i, o = e.index, r = this.chart;
                            for (a = 0, n = (r.data.datasets || []).length; a < n; ++a) (i = r.getDatasetMeta(a)).data[o].hidden = !i.data[o].hidden;
                            r.update();
                        }
                    },
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(t, e) {
                                return e.labels[t.index] + ": " + t.yLabel;
                            }
                        }
                    }
                }, e.controllers.polarArea = e.DatasetController.extend({
                    dataElementType: e.elements.Arc,
                    linkScales: S.noop,
                    update: function(a) {
                        var n = this, t = n.chart, e = t.chartArea, i = n.getMeta(), o = t.options, r = o.elements.arc, l = Math.min(e.right - e.left, e.bottom - e.top);
                        t.outerRadius = Math.max((l - r.borderWidth / 2) / 2, 0), t.innerRadius = Math.max(o.cutoutPercentage ? t.outerRadius / 100 * o.cutoutPercentage : 1, 0), 
                        t.radiusLength = (t.outerRadius - t.innerRadius) / t.getVisibleDatasetCount(), n.outerRadius = t.outerRadius - t.radiusLength * n.index, 
                        n.innerRadius = n.outerRadius - t.radiusLength, i.count = n.countVisibleElements(), 
                        S.each(i.data, function(t, e) {
                            n.updateElement(t, e, a);
                        });
                    },
                    updateElement: function(t, e, a) {
                        for (var n = this, i = n.chart, o = n.getDataset(), r = i.options, l = r.animation, s = i.scale, d = S.getValueAtIndexOrDefault, u = i.data.labels, c = n.calculateCircumference(o.data[e]), h = s.xCenter, f = s.yCenter, g = 0, p = n.getMeta(), m = 0; m < e; ++m) isNaN(o.data[m]) || p.data[m].hidden || ++g;
                        var b = r.startAngle, v = t.hidden ? 0 : s.getDistanceFromCenterForValue(o.data[e]), x = b + c * g, y = x + (t.hidden ? 0 : c), k = l.animateScale ? 0 : s.getDistanceFromCenterForValue(o.data[e]);
                        S.extend(t, {
                            _datasetIndex: n.index,
                            _index: e,
                            _scale: s,
                            _model: {
                                x: h,
                                y: f,
                                innerRadius: 0,
                                outerRadius: a ? k : v,
                                startAngle: a && l.animateRotate ? b : x,
                                endAngle: a && l.animateRotate ? b : y,
                                label: d(u, e, u[e])
                            }
                        }), n.removeHoverStyle(t), t.pivot();
                    },
                    removeHoverStyle: function(t) {
                        e.DatasetController.prototype.removeHoverStyle.call(this, t, this.chart.options.elements.arc);
                    },
                    countVisibleElements: function() {
                        var a = this.getDataset(), t = this.getMeta(), n = 0;
                        return S.each(t.data, function(t, e) {
                            isNaN(a.data[e]) || t.hidden || n++;
                        }), n;
                    },
                    calculateCircumference: function(t) {
                        var e = this.getMeta().count;
                        return 0 < e && !isNaN(t) ? 2 * Math.PI / e : 0;
                    }
                });
            };
        }, {} ],
        14: [ function(t, e, a) {
            e.exports = function(t) {
                var d = t.helpers;
                t.defaults.radar = {
                    aspectRatio: 1,
                    scale: {
                        type: "radialLinear"
                    },
                    elements: {
                        line: {
                            tension: 0
                        }
                    }
                }, t.controllers.radar = t.DatasetController.extend({
                    datasetElementType: t.elements.Line,
                    dataElementType: t.elements.Point,
                    linkScales: d.noop,
                    update: function(a) {
                        var n = this, t = n.getMeta(), e = t.dataset, i = t.data, o = e.custom || {}, r = n.getDataset(), l = n.chart.options.elements.line, s = n.chart.scale;
                        void 0 !== r.tension && void 0 === r.lineTension && (r.lineTension = r.tension), 
                        d.extend(t.dataset, {
                            _datasetIndex: n.index,
                            _children: i,
                            _loop: !0,
                            _model: {
                                tension: o.tension ? o.tension : d.getValueOrDefault(r.lineTension, l.tension),
                                backgroundColor: o.backgroundColor ? o.backgroundColor : r.backgroundColor || l.backgroundColor,
                                borderWidth: o.borderWidth ? o.borderWidth : r.borderWidth || l.borderWidth,
                                borderColor: o.borderColor ? o.borderColor : r.borderColor || l.borderColor,
                                fill: o.fill ? o.fill : void 0 !== r.fill ? r.fill : l.fill,
                                borderCapStyle: o.borderCapStyle ? o.borderCapStyle : r.borderCapStyle || l.borderCapStyle,
                                borderDash: o.borderDash ? o.borderDash : r.borderDash || l.borderDash,
                                borderDashOffset: o.borderDashOffset ? o.borderDashOffset : r.borderDashOffset || l.borderDashOffset,
                                borderJoinStyle: o.borderJoinStyle ? o.borderJoinStyle : r.borderJoinStyle || l.borderJoinStyle,
                                scaleTop: s.top,
                                scaleBottom: s.bottom,
                                scaleZero: s.getBasePosition()
                            }
                        }), t.dataset.pivot(), d.each(i, function(t, e) {
                            n.updateElement(t, e, a);
                        }, n), n.updateBezierControlPoints();
                    },
                    updateElement: function(t, e, a) {
                        var n = this, i = t.custom || {}, o = n.getDataset(), r = n.chart.scale, l = n.chart.options.elements.point, s = r.getPointPositionForValue(e, o.data[e]);
                        d.extend(t, {
                            _datasetIndex: n.index,
                            _index: e,
                            _scale: r,
                            _model: {
                                x: a ? r.xCenter : s.x,
                                y: a ? r.yCenter : s.y,
                                tension: i.tension ? i.tension : d.getValueOrDefault(o.tension, n.chart.options.elements.line.tension),
                                radius: i.radius ? i.radius : d.getValueAtIndexOrDefault(o.pointRadius, e, l.radius),
                                backgroundColor: i.backgroundColor ? i.backgroundColor : d.getValueAtIndexOrDefault(o.pointBackgroundColor, e, l.backgroundColor),
                                borderColor: i.borderColor ? i.borderColor : d.getValueAtIndexOrDefault(o.pointBorderColor, e, l.borderColor),
                                borderWidth: i.borderWidth ? i.borderWidth : d.getValueAtIndexOrDefault(o.pointBorderWidth, e, l.borderWidth),
                                pointStyle: i.pointStyle ? i.pointStyle : d.getValueAtIndexOrDefault(o.pointStyle, e, l.pointStyle),
                                hitRadius: i.hitRadius ? i.hitRadius : d.getValueAtIndexOrDefault(o.hitRadius, e, l.hitRadius)
                            }
                        }), t._model.skip = i.skip ? i.skip : isNaN(t._model.x) || isNaN(t._model.y);
                    },
                    updateBezierControlPoints: function() {
                        var i = this.chart.chartArea, o = this.getMeta();
                        d.each(o.data, function(t, e) {
                            var a = t._model, n = d.splineCurve(d.previousItem(o.data, e, !0)._model, a, d.nextItem(o.data, e, !0)._model, a.tension);
                            a.controlPointPreviousX = Math.max(Math.min(n.previous.x, i.right), i.left), a.controlPointPreviousY = Math.max(Math.min(n.previous.y, i.bottom), i.top), 
                            a.controlPointNextX = Math.max(Math.min(n.next.x, i.right), i.left), a.controlPointNextY = Math.max(Math.min(n.next.y, i.bottom), i.top), 
                            t.pivot();
                        });
                    },
                    draw: function(t) {
                        var e = this.getMeta(), a = t || 1;
                        d.each(e.data, function(t) {
                            t.transition(a);
                        }), e.dataset.transition(a).draw(), d.each(e.data, function(t) {
                            t.draw();
                        });
                    },
                    setHoverStyle: function(t) {
                        var e = this.chart.data.datasets[t._datasetIndex], a = t.custom || {}, n = t._index, i = t._model;
                        i.radius = a.hoverRadius ? a.hoverRadius : d.getValueAtIndexOrDefault(e.pointHoverRadius, n, this.chart.options.elements.point.hoverRadius), 
                        i.backgroundColor = a.hoverBackgroundColor ? a.hoverBackgroundColor : d.getValueAtIndexOrDefault(e.pointHoverBackgroundColor, n, d.getHoverColor(i.backgroundColor)), 
                        i.borderColor = a.hoverBorderColor ? a.hoverBorderColor : d.getValueAtIndexOrDefault(e.pointHoverBorderColor, n, d.getHoverColor(i.borderColor)), 
                        i.borderWidth = a.hoverBorderWidth ? a.hoverBorderWidth : d.getValueAtIndexOrDefault(e.pointHoverBorderWidth, n, i.borderWidth);
                    },
                    removeHoverStyle: function(t) {
                        var e = this.chart.data.datasets[t._datasetIndex], a = t.custom || {}, n = t._index, i = t._model, o = this.chart.options.elements.point;
                        i.radius = a.radius ? a.radius : d.getValueAtIndexOrDefault(e.radius, n, o.radius), 
                        i.backgroundColor = a.backgroundColor ? a.backgroundColor : d.getValueAtIndexOrDefault(e.pointBackgroundColor, n, o.backgroundColor), 
                        i.borderColor = a.borderColor ? a.borderColor : d.getValueAtIndexOrDefault(e.pointBorderColor, n, o.borderColor), 
                        i.borderWidth = a.borderWidth ? a.borderWidth : d.getValueAtIndexOrDefault(e.pointBorderWidth, n, o.borderWidth);
                    }
                });
            };
        }, {} ],
        15: [ function(t, e, a) {
            e.exports = function(t) {
                var a = t.helpers;
                t.defaults.global.animation = {
                    duration: 1e3,
                    easing: "easeOutQuart",
                    onProgress: a.noop,
                    onComplete: a.noop
                }, t.Animation = t.Element.extend({
                    currentStep: null,
                    numSteps: 60,
                    easing: "",
                    render: null,
                    onAnimationProgress: null,
                    onAnimationComplete: null
                }), t.animationService = {
                    frameDuration: 17,
                    animations: [],
                    dropFrames: 0,
                    request: null,
                    addAnimation: function(t, e, a, n) {
                        var i = this;
                        n || (t.animating = !0);
                        for (var o = 0; o < i.animations.length; ++o) if (i.animations[o].chartInstance === t) return void (i.animations[o].animationObject = e);
                        i.animations.push({
                            chartInstance: t,
                            animationObject: e
                        }), 1 === i.animations.length && i.requestAnimationFrame();
                    },
                    cancelAnimation: function(e) {
                        var t = a.findIndex(this.animations, function(t) {
                            return t.chartInstance === e;
                        });
                        -1 !== t && (this.animations.splice(t, 1), e.animating = !1);
                    },
                    requestAnimationFrame: function() {
                        var t = this;
                        null === t.request && (t.request = a.requestAnimFrame.call(window, function() {
                            t.request = null, t.startDigest();
                        }));
                    },
                    startDigest: function() {
                        var t = this, e = Date.now(), a = 0;
                        1 < t.dropFrames && (a = Math.floor(t.dropFrames), t.dropFrames = t.dropFrames % 1);
                        for (var n = 0; n < t.animations.length; ) null === t.animations[n].animationObject.currentStep && (t.animations[n].animationObject.currentStep = 0), 
                        t.animations[n].animationObject.currentStep += 1 + a, t.animations[n].animationObject.currentStep > t.animations[n].animationObject.numSteps && (t.animations[n].animationObject.currentStep = t.animations[n].animationObject.numSteps), 
                        t.animations[n].animationObject.render(t.animations[n].chartInstance, t.animations[n].animationObject), 
                        t.animations[n].animationObject.onAnimationProgress && t.animations[n].animationObject.onAnimationProgress.call && t.animations[n].animationObject.onAnimationProgress.call(t.animations[n].chartInstance, t.animations[n]), 
                        t.animations[n].animationObject.currentStep === t.animations[n].animationObject.numSteps ? (t.animations[n].animationObject.onAnimationComplete && t.animations[n].animationObject.onAnimationComplete.call && t.animations[n].animationObject.onAnimationComplete.call(t.animations[n].chartInstance, t.animations[n]), 
                        t.animations[n].chartInstance.animating = !1, t.animations.splice(n, 1)) : ++n;
                        var i = (Date.now() - e) / t.frameDuration;
                        t.dropFrames += i, 0 < t.animations.length && t.requestAnimationFrame();
                    }
                };
            };
        }, {} ],
        16: [ function(t, e, a) {
            e.exports = function(t) {
                (t.canvasHelpers = {}).drawPoint = function(t, e, a, n, i) {
                    var o, r, l, s, d, u;
                    if ("object" != (void 0 === e ? "undefined" : m(e)) || "[object HTMLImageElement]" !== (o = e.toString()) && "[object HTMLCanvasElement]" !== o) {
                        if (!(isNaN(a) || a <= 0)) {
                            switch (e) {
                              default:
                                t.beginPath(), t.arc(n, i, a, 0, 2 * Math.PI), t.closePath(), t.fill();
                                break;

                              case "triangle":
                                t.beginPath(), d = (r = 3 * a / Math.sqrt(3)) * Math.sqrt(3) / 2, t.moveTo(n - r / 2, i + d / 3), 
                                t.lineTo(n + r / 2, i + d / 3), t.lineTo(n, i - 2 * d / 3), t.closePath(), t.fill();
                                break;

                              case "rect":
                                u = 1 / Math.SQRT2 * a, t.beginPath(), t.fillRect(n - u, i - u, 2 * u, 2 * u), t.strokeRect(n - u, i - u, 2 * u, 2 * u);
                                break;

                              case "rectRot":
                                u = 1 / Math.SQRT2 * a, t.beginPath(), t.moveTo(n - u, i), t.lineTo(n, i + u), t.lineTo(n + u, i), 
                                t.lineTo(n, i - u), t.closePath(), t.fill();
                                break;

                              case "cross":
                                t.beginPath(), t.moveTo(n, i + a), t.lineTo(n, i - a), t.moveTo(n - a, i), t.lineTo(n + a, i), 
                                t.closePath();
                                break;

                              case "crossRot":
                                t.beginPath(), l = Math.cos(Math.PI / 4) * a, s = Math.sin(Math.PI / 4) * a, t.moveTo(n - l, i - s), 
                                t.lineTo(n + l, i + s), t.moveTo(n - l, i + s), t.lineTo(n + l, i - s), t.closePath();
                                break;

                              case "star":
                                t.beginPath(), t.moveTo(n, i + a), t.lineTo(n, i - a), t.moveTo(n - a, i), t.lineTo(n + a, i), 
                                l = Math.cos(Math.PI / 4) * a, s = Math.sin(Math.PI / 4) * a, t.moveTo(n - l, i - s), 
                                t.lineTo(n + l, i + s), t.moveTo(n - l, i + s), t.lineTo(n + l, i - s), t.closePath();
                                break;

                              case "line":
                                t.beginPath(), t.moveTo(n - a, i), t.lineTo(n + a, i), t.closePath();
                                break;

                              case "dash":
                                t.beginPath(), t.moveTo(n, i), t.lineTo(n + a, i), t.closePath();
                            }
                            t.stroke();
                        }
                    } else t.drawImage(e, n - e.width / 2, i - e.height / 2);
                };
            };
        }, {} ],
        17: [ function(t, e, a) {
            e.exports = function(u) {
                function l(t, e) {
                    var a = h.getStyle(t, e), n = a && a.match(/(\d+)px/);
                    return n ? Number(n[1]) : void 0;
                }
                function c(t, e) {
                    var a = t;
                    return function(t, e) {
                        var a = t.style, n = t.getAttribute("height"), i = t.getAttribute("width");
                        if (t._chartjs = {
                            initial: {
                                height: n,
                                width: i,
                                style: {
                                    display: a.display,
                                    height: a.height,
                                    width: a.width
                                }
                            }
                        }, a.display = a.display || "block", null === i || "" === i) {
                            var o = l(t, "width");
                            void 0 !== o && (t.width = o);
                        }
                        if (null === n || "" === n) if ("" === t.style.height) t.height = t.width / (e.options.aspectRatio || 2); else {
                            var r = l(t, "height");
                            void 0 !== o && (t.height = r);
                        }
                    }(t.canvas, e), a;
                }
                var h = u.helpers;
                u.types = {}, u.instances = {}, u.controllers = {}, u.Controller = function(t, e, a) {
                    var n, i, o = this;
                    (i = (n = (n = e) || {}).data = n.data || {}).datasets = i.datasets || [], i.labels = i.labels || [], 
                    n.options = h.configMerge(u.defaults.global, u.defaults[n.type], n.options || {});
                    var r = c(t, e = n), l = r && r.canvas, s = l && l.height, d = l && l.width;
                    return a.ctx = r, a.canvas = l, a.config = e, a.width = d, a.height = s, a.aspectRatio = s ? d / s : null, 
                    o.id = h.uid(), o.chart = a, o.config = e, o.options = e.options, o._bufferedRender = !1, 
                    u.instances[o.id] = o, Object.defineProperty(o, "data", {
                        get: function() {
                            return o.config.data;
                        }
                    }), r && l ? (h.retinaScale(a), o.options.responsive && (h.addResizeListener(l.parentNode, function() {
                        o.resize();
                    }), o.resize(!0)), o.initialize()) : console.error("Failed to create chart: can't acquire context from the given item"), 
                    o;
                }, h.extend(u.Controller.prototype, {
                    initialize: function() {
                        var t = this;
                        return u.plugins.notify("beforeInit", [ t ]), t.bindEvents(), t.ensureScalesHaveIDs(), 
                        t.buildOrUpdateControllers(), t.buildScales(), t.updateLayout(), t.resetElements(), 
                        t.initToolTip(), t.update(), u.plugins.notify("afterInit", [ t ]), t;
                    },
                    clear: function() {
                        return h.clear(this.chart), this;
                    },
                    stop: function() {
                        return u.animationService.cancelAnimation(this), this;
                    },
                    resize: function(t) {
                        var e = this, a = e.chart, n = e.options, i = a.canvas, o = n.maintainAspectRatio && a.aspectRatio || null, r = Math.floor(h.getMaximumWidth(i)), l = Math.floor(o ? r / o : h.getMaximumHeight(i));
                        if (a.width !== r || a.height !== l) {
                            i.width = a.width = r, i.height = a.height = l, h.retinaScale(a), i.style.width = r + "px", 
                            i.style.height = l + "px";
                            var s = {
                                width: r,
                                height: l
                            };
                            u.plugins.notify("resize", [ e, s ]), e.options.onResize && e.options.onResize(e, s), 
                            t || (e.stop(), e.update(e.options.responsiveAnimationDuration));
                        }
                    },
                    ensureScalesHaveIDs: function() {
                        var t = this.options, e = t.scales || {}, a = t.scale;
                        h.each(e.xAxes, function(t, e) {
                            t.id = t.id || "x-axis-" + e;
                        }), h.each(e.yAxes, function(t, e) {
                            t.id = t.id || "y-axis-" + e;
                        }), a && (a.id = a.id || "scale");
                    },
                    buildScales: function() {
                        var o = this, t = o.options, r = o.scales = {}, e = [];
                        t.scales && (e = e.concat((t.scales.xAxes || []).map(function(t) {
                            return {
                                options: t,
                                dtype: "category"
                            };
                        }), (t.scales.yAxes || []).map(function(t) {
                            return {
                                options: t,
                                dtype: "linear"
                            };
                        }))), t.scale && e.push({
                            options: t.scale,
                            dtype: "radialLinear",
                            isDefault: !0
                        }), h.each(e, function(t) {
                            var e = t.options, a = h.getValueOrDefault(e.type, t.dtype), n = u.scaleService.getScaleConstructor(a);
                            if (n) {
                                var i = new n({
                                    id: e.id,
                                    options: e,
                                    ctx: o.chart.ctx,
                                    chart: o
                                });
                                r[i.id] = i, t.isDefault && (o.scale = i);
                            }
                        }), u.scaleService.addScalesToLayout(this);
                    },
                    updateLayout: function() {
                        u.layoutService.update(this, this.chart.width, this.chart.height);
                    },
                    buildOrUpdateControllers: function() {
                        var n = this, i = [], o = [];
                        if (h.each(n.data.datasets, function(t, e) {
                            var a = n.getDatasetMeta(e);
                            a.type || (a.type = t.type || n.config.type), i.push(a.type), a.controller ? a.controller.updateIndex(e) : (a.controller = new u.controllers[a.type](n, e), 
                            o.push(a.controller));
                        }, n), 1 < i.length) for (var t = 1; t < i.length; t++) if (i[t] !== i[t - 1]) {
                            n.isCombo = !0;
                            break;
                        }
                        return o;
                    },
                    resetElements: function() {
                        var a = this;
                        h.each(a.data.datasets, function(t, e) {
                            a.getDatasetMeta(e).controller.reset();
                        }, a);
                    },
                    reset: function() {
                        this.resetElements(), this.tooltip.initialize();
                    },
                    update: function(t, e) {
                        var a = this;
                        u.plugins.notify("beforeUpdate", [ a ]), a.tooltip._data = a.data;
                        var n = a.buildOrUpdateControllers();
                        h.each(a.data.datasets, function(t, e) {
                            a.getDatasetMeta(e).controller.buildOrUpdateElements();
                        }, a), u.layoutService.update(a, a.chart.width, a.chart.height), u.plugins.notify("afterScaleUpdate", [ a ]), 
                        h.each(n, function(t) {
                            t.reset();
                        }), a.updateDatasets(), u.plugins.notify("afterUpdate", [ a ]), a._bufferedRender ? a._bufferedRequest = {
                            lazy: e,
                            duration: t
                        } : a.render(t, e);
                    },
                    updateDatasets: function() {
                        var t, e;
                        if (u.plugins.notify("beforeDatasetsUpdate", [ this ])) {
                            for (t = 0, e = this.data.datasets.length; t < e; ++t) this.getDatasetMeta(t).controller.update();
                            u.plugins.notify("afterDatasetsUpdate", [ this ]);
                        }
                    },
                    render: function(t, e) {
                        var a = this;
                        u.plugins.notify("beforeRender", [ a ]);
                        var n = a.options.animation;
                        if (n && (void 0 !== t && 0 !== t || void 0 === t && 0 !== n.duration)) {
                            var i = new u.Animation();
                            i.numSteps = (t || n.duration) / 16.66, i.easing = n.easing, i.render = function(t, e) {
                                var a = h.easingEffects[e.easing], n = e.currentStep / e.numSteps, i = a(n);
                                t.draw(i, n, e.currentStep);
                            }, i.onAnimationProgress = n.onProgress, i.onAnimationComplete = n.onComplete, u.animationService.addAnimation(a, i, t, e);
                        } else a.draw(), n && n.onComplete && n.onComplete.call && n.onComplete.call(a);
                        return a;
                    },
                    draw: function(a) {
                        var n = this, t = a || 1;
                        n.clear(), u.plugins.notify("beforeDraw", [ n, t ]), h.each(n.boxes, function(t) {
                            t.draw(n.chartArea, t);
                        }, n), n.scale && n.scale.draw(), u.plugins.notify("beforeDatasetsDraw", [ n, t ]), 
                        h.each(n.data.datasets, function(t, e) {
                            n.isDatasetVisible(e) && n.getDatasetMeta(e).controller.draw(a);
                        }, n, !0), u.plugins.notify("afterDatasetsDraw", [ n, t ]), n.tooltip.transition(t).draw(), 
                        u.plugins.notify("afterDraw", [ n, t ]);
                    },
                    getElementAtEvent: function(t) {
                        return u.Interaction.modes.single(this, t);
                    },
                    getElementsAtEvent: function(t) {
                        return u.Interaction.modes.label(this, t, {
                            intersect: !0
                        });
                    },
                    getElementsAtXAxis: function(t) {
                        return u.Interaction.modes["x-axis"](this, t, {
                            intersect: !0
                        });
                    },
                    getElementsAtEventForMode: function(t, e, a) {
                        var n = u.Interaction.modes[e];
                        return "function" == typeof n ? n(this, t, a) : [];
                    },
                    getDatasetAtEvent: function(t) {
                        return u.Interaction.modes.dataset(this, t);
                    },
                    getDatasetMeta: function(t) {
                        var e = this.data.datasets[t];
                        e._meta || (e._meta = {});
                        var a = e._meta[this.id];
                        return a || (a = e._meta[this.id] = {
                            type: null,
                            data: [],
                            dataset: null,
                            controller: null,
                            hidden: null,
                            xAxisID: null,
                            yAxisID: null
                        }), a;
                    },
                    getVisibleDatasetCount: function() {
                        for (var t = 0, e = 0, a = this.data.datasets.length; e < a; ++e) this.isDatasetVisible(e) && t++;
                        return t;
                    },
                    isDatasetVisible: function(t) {
                        var e = this.getDatasetMeta(t);
                        return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden;
                    },
                    generateLegend: function() {
                        return this.options.legendCallback(this);
                    },
                    destroy: function() {
                        var t, e, a, n = this, i = n.chart.canvas;
                        for (n.stop(), e = 0, a = n.data.datasets.length; e < a; ++e) (t = n.getDatasetMeta(e)).controller && (t.controller.destroy(), 
                        t.controller = null);
                        i && (h.unbindEvents(n, n.events), h.removeResizeListener(i.parentNode), h.clear(n.chart), 
                        function(a) {
                            if (a._chartjs) {
                                var n = a._chartjs.initial;
                                [ "height", "width" ].forEach(function(t) {
                                    var e = n[t];
                                    null == e ? a.removeAttribute(t) : a.setAttribute(t, e);
                                }), h.each(n.style || {}, function(t, e) {
                                    a.style[e] = t;
                                }), delete a._chartjs;
                            }
                        }(i), n.chart.canvas = null, n.chart.ctx = null), void 0 !== n.chart.originalDevicePixelRatio && n.chart.ctx.scale(1 / n.chart.originalDevicePixelRatio, 1 / n.chart.originalDevicePixelRatio), 
                        u.plugins.notify("destroy", [ n ]), delete u.instances[n.id];
                    },
                    toBase64Image: function() {
                        return this.chart.canvas.toDataURL.apply(this.chart.canvas, arguments);
                    },
                    initToolTip: function() {
                        var t = this;
                        t.tooltip = new u.Tooltip({
                            _chart: t.chart,
                            _chartInstance: t,
                            _data: t.data,
                            _options: t.options.tooltips
                        }, t), t.tooltip.initialize();
                    },
                    bindEvents: function() {
                        var e = this;
                        h.bindEvents(e, e.options.events, function(t) {
                            e.eventHandler(t);
                        });
                    },
                    updateHoverStyle: function(t, e, a) {
                        var n, i, o, r = a ? "setHoverStyle" : "removeHoverStyle";
                        for (i = 0, o = t.length; i < o; ++i) (n = t[i]) && this.getDatasetMeta(n._datasetIndex).controller[r](n);
                    },
                    eventHandler: function(t) {
                        var e = this, a = e.options.hover;
                        e._bufferedRender = !0, e._bufferedRequest = null;
                        var n = e.handleEvent(t);
                        n |= e.legend.handleEvent(t), n |= e.tooltip.handleEvent(t);
                        var i = e._bufferedRequest;
                        return i ? e.render(i.duration, i.lazy) : n && !e.animating && (e.stop(), e.render(a.animationDuration, !0)), 
                        e._bufferedRender = !1, e._bufferedRequest = null, e;
                    },
                    handleEvent: function(t) {
                        var e, a = this, n = a.options || {}, i = n.hover;
                        return a.lastActive = a.lastActive || [], "mouseout" === t.type ? a.active = [] : a.active = a.getElementsAtEventForMode(t, i.mode, i), 
                        i.onHover && i.onHover.call(a, a.active), ("mouseup" === t.type || "click" === t.type) && n.onClick && n.onClick.call(a, t, a.active), 
                        a.lastActive.length && a.updateHoverStyle(a.lastActive, i.mode, !1), a.active.length && i.mode && a.updateHoverStyle(a.active, i.mode, !0), 
                        e = !h.arrayEquals(a.active, a.lastActive), a.lastActive = a.active, e;
                    }
                });
            };
        }, {} ],
        18: [ function(t, e, a) {
            e.exports = function(t) {
                function o(e, t) {
                    var a = e._chartjs;
                    if (a) {
                        var n = a.listeners, i = n.indexOf(t);
                        -1 !== i && n.splice(i, 1), 0 < n.length || (r.forEach(function(t) {
                            delete e[t];
                        }), delete e._chartjs);
                    }
                }
                var l = t.helpers, r = [ "push", "pop", "shift", "splice", "unshift" ];
                t.DatasetController = function(t, e) {
                    this.initialize(t, e);
                }, l.extend(t.DatasetController.prototype, {
                    datasetElementType: null,
                    dataElementType: null,
                    initialize: function(t, e) {
                        this.chart = t, this.index = e, this.linkScales(), this.addElements();
                    },
                    updateIndex: function(t) {
                        this.index = t;
                    },
                    linkScales: function() {
                        var t = this.getMeta(), e = this.getDataset();
                        null === t.xAxisID && (t.xAxisID = e.xAxisID || this.chart.options.scales.xAxes[0].id), 
                        null === t.yAxisID && (t.yAxisID = e.yAxisID || this.chart.options.scales.yAxes[0].id);
                    },
                    getDataset: function() {
                        return this.chart.data.datasets[this.index];
                    },
                    getMeta: function() {
                        return this.chart.getDatasetMeta(this.index);
                    },
                    getScaleForId: function(t) {
                        return this.chart.scales[t];
                    },
                    reset: function() {
                        this.update(!0);
                    },
                    destroy: function() {
                        this._data && o(this._data, this);
                    },
                    createMetaDataset: function() {
                        var t = this.datasetElementType;
                        return t && new t({
                            _chart: this.chart.chart,
                            _datasetIndex: this.index
                        });
                    },
                    createMetaData: function(t) {
                        var e = this.dataElementType;
                        return e && new e({
                            _chart: this.chart.chart,
                            _datasetIndex: this.index,
                            _index: t
                        });
                    },
                    addElements: function() {
                        var t, e, a = this.getMeta(), n = this.getDataset().data || [], i = a.data;
                        for (t = 0, e = n.length; t < e; ++t) i[t] = i[t] || this.createMetaData(t);
                        a.dataset = a.dataset || this.createMetaDataset();
                    },
                    addElementAndReset: function(t) {
                        var e = this.createMetaData(t);
                        this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0);
                    },
                    buildOrUpdateElements: function() {
                        var i, t, e = this, a = e.getDataset(), n = a.data || (a.data = []);
                        e._data !== n && (e._data && o(e._data, e), t = e, (i = n)._chartjs ? i._chartjs.listeners.push(t) : (Object.defineProperty(i, "_chartjs", {
                            configurable: !0,
                            enumerable: !1,
                            value: {
                                listeners: [ t ]
                            }
                        }), r.forEach(function(t) {
                            var a = "onData" + t.charAt(0).toUpperCase() + t.slice(1), n = i[t];
                            Object.defineProperty(i, t, {
                                configurable: !0,
                                enumerable: !1,
                                value: function() {
                                    var e = Array.prototype.slice.call(arguments), t = n.apply(this, e);
                                    return l.each(i._chartjs.listeners, function(t) {
                                        "function" == typeof t[a] && t[a].apply(t, e);
                                    }), t;
                                }
                            });
                        })), e._data = n), e.resyncElements();
                    },
                    update: l.noop,
                    draw: function(t) {
                        var e, a, n = t || 1, i = this.getMeta().data;
                        for (e = 0, a = i.length; e < a; ++e) i[e].transition(n).draw();
                    },
                    removeHoverStyle: function(t, e) {
                        var a = this.chart.data.datasets[t._datasetIndex], n = t._index, i = t.custom || {}, o = l.getValueAtIndexOrDefault, r = t._model;
                        r.backgroundColor = i.backgroundColor ? i.backgroundColor : o(a.backgroundColor, n, e.backgroundColor), 
                        r.borderColor = i.borderColor ? i.borderColor : o(a.borderColor, n, e.borderColor), 
                        r.borderWidth = i.borderWidth ? i.borderWidth : o(a.borderWidth, n, e.borderWidth);
                    },
                    setHoverStyle: function(t) {
                        var e = this.chart.data.datasets[t._datasetIndex], a = t._index, n = t.custom || {}, i = l.getValueAtIndexOrDefault, o = l.getHoverColor, r = t._model;
                        r.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : i(e.hoverBackgroundColor, a, o(r.backgroundColor)), 
                        r.borderColor = n.hoverBorderColor ? n.hoverBorderColor : i(e.hoverBorderColor, a, o(r.borderColor)), 
                        r.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : i(e.hoverBorderWidth, a, r.borderWidth);
                    },
                    resyncElements: function() {
                        var t = this.getMeta(), e = this.getDataset().data, a = t.data.length, n = e.length;
                        n < a ? t.data.splice(n, a - n) : a < n && this.insertElements(a, n - a);
                    },
                    insertElements: function(t, e) {
                        for (var a = 0; a < e; ++a) this.addElementAndReset(t + a);
                    },
                    onDataPush: function() {
                        this.insertElements(this.getDataset().data.length - 1, arguments.length);
                    },
                    onDataPop: function() {
                        this.getMeta().data.pop();
                    },
                    onDataShift: function() {
                        this.getMeta().data.shift();
                    },
                    onDataSplice: function(t, e) {
                        this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2);
                    },
                    onDataUnshift: function() {
                        this.insertElements(0, arguments.length);
                    }
                }), t.DatasetController.extend = l.inherits;
            };
        }, {} ],
        19: [ function(t, e, a) {
            e.exports = function(t) {
                var r = t.helpers;
                t.elements = {}, t.Element = function(t) {
                    r.extend(this, t), this.initialize.apply(this, arguments);
                }, r.extend(t.Element.prototype, {
                    initialize: function() {
                        this.hidden = !1;
                    },
                    pivot: function() {
                        var t = this;
                        return t._view || (t._view = r.clone(t._model)), t._start = r.clone(t._view), t;
                    },
                    transition: function(i) {
                        var o = this;
                        return o._view || (o._view = r.clone(o._model)), 1 === i ? (o._view = o._model, 
                        o._start = null) : (o._start || o.pivot(), r.each(o._model, function(e, a) {
                            if ("_" === a[0]) ; else if (o._view.hasOwnProperty(a)) if (e === o._view[a]) ; else if ("string" == typeof e) try {
                                var t = r.color(o._model[a]).mix(r.color(o._start[a]), i);
                                o._view[a] = t.rgbString();
                            } catch (t) {
                                o._view[a] = e;
                            } else if ("number" == typeof e) {
                                var n = void 0 !== o._start[a] && !1 === isNaN(o._start[a]) ? o._start[a] : 0;
                                o._view[a] = (o._model[a] - n) * i + n;
                            } else o._view[a] = e; else "number" != typeof e || isNaN(o._view[a]) ? o._view[a] = e : o._view[a] = e * i;
                        }, o)), o;
                    },
                    tooltipPosition: function() {
                        return {
                            x: this._model.x,
                            y: this._model.y
                        };
                    },
                    hasValue: function() {
                        return r.isNumber(this._model.x) && r.isNumber(this._model.y);
                    }
                }), t.Element.extend = r.inherits;
            };
        }, {} ],
        20: [ function(t, e, a) {
            var n = t(36);
            e.exports = function(r) {
                function u(t, e, a) {
                    var n;
                    return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[a])) : n = t, 
                    n;
                }
                function c(t) {
                    return null != t && "none" !== t;
                }
                function e(t, e, a) {
                    var n = document.defaultView, i = t.parentNode, o = n.getComputedStyle(t)[e], r = n.getComputedStyle(i)[e], l = c(o), s = c(r), d = Number.POSITIVE_INFINITY;
                    return l || s ? Math.min(l ? u(o, t, a) : d, s ? u(r, i, a) : d) : "none";
                }
                var t, g = r.helpers = {};
                g.each = function(t, e, a, n) {
                    var i, o;
                    if (g.isArray(t)) if (o = t.length, n) for (i = o - 1; 0 <= i; i--) e.call(a, t[i], i); else for (i = 0; i < o; i++) e.call(a, t[i], i); else if ("object" == (void 0 === t ? "undefined" : m(t))) {
                        var r = Object.keys(t);
                        for (o = r.length, i = 0; i < o; i++) e.call(a, t[r[i]], r[i]);
                    }
                }, g.clone = function(t) {
                    var a = {};
                    return g.each(t, function(t, e) {
                        g.isArray(t) ? a[e] = t.slice(0) : "object" == (void 0 === t ? "undefined" : m(t)) && null !== t ? a[e] = g.clone(t) : a[e] = t;
                    }), a;
                }, g.extend = function(a) {
                    for (var t = function(t, e) {
                        a[e] = t;
                    }, e = 1, n = arguments.length; e < n; e++) g.each(arguments[e], t);
                    return a;
                }, g.configMerge = function(t) {
                    var i = g.clone(t);
                    return g.each(Array.prototype.slice.call(arguments, 1), function(t) {
                        g.each(t, function(t, e) {
                            var a = i.hasOwnProperty(e), n = a ? i[e] : {};
                            "scales" === e ? i[e] = g.scaleMerge(n, t) : "scale" === e ? i[e] = g.configMerge(n, r.scaleService.getScaleDefaults(t.type), t) : !a || "object" != (void 0 === n ? "undefined" : m(n)) || g.isArray(n) || null === n || "object" != (void 0 === t ? "undefined" : m(t)) || g.isArray(t) ? i[e] = t : i[e] = g.configMerge(n, t);
                        });
                    }), i;
                }, g.scaleMerge = function(t, e) {
                    var o = g.clone(t);
                    return g.each(e, function(t, i) {
                        "xAxes" === i || "yAxes" === i ? o.hasOwnProperty(i) ? g.each(t, function(t, e) {
                            var a = g.getValueOrDefault(t.type, "xAxes" === i ? "category" : "linear"), n = r.scaleService.getScaleDefaults(a);
                            e >= o[i].length || !o[i][e].type ? o[i].push(g.configMerge(n, t)) : t.type && t.type !== o[i][e].type ? o[i][e] = g.configMerge(o[i][e], n, t) : o[i][e] = g.configMerge(o[i][e], t);
                        }) : (o[i] = [], g.each(t, function(t) {
                            var e = g.getValueOrDefault(t.type, "xAxes" === i ? "category" : "linear");
                            o[i].push(g.configMerge(r.scaleService.getScaleDefaults(e), t));
                        })) : o.hasOwnProperty(i) && "object" == m(o[i]) && null !== o[i] && "object" == (void 0 === t ? "undefined" : m(t)) ? o[i] = g.configMerge(o[i], t) : o[i] = t;
                    }), o;
                }, g.getValueAtIndexOrDefault = function(t, e, a) {
                    return null == t ? a : g.isArray(t) ? e < t.length ? t[e] : a : t;
                }, g.getValueOrDefault = function(t, e) {
                    return void 0 === t ? e : t;
                }, g.indexOf = Array.prototype.indexOf ? function(t, e) {
                    return t.indexOf(e);
                } : function(t, e) {
                    for (var a = 0, n = t.length; a < n; ++a) if (t[a] === e) return a;
                    return -1;
                }, g.where = function(t, e) {
                    if (g.isArray(t) && Array.prototype.filter) return t.filter(e);
                    var a = [];
                    return g.each(t, function(t) {
                        e(t) && a.push(t);
                    }), a;
                }, g.findIndex = Array.prototype.findIndex ? function(t, e, a) {
                    return t.findIndex(e, a);
                } : function(t, e, a) {
                    a = void 0 === a ? t : a;
                    for (var n = 0, i = t.length; n < i; ++n) if (e.call(a, t[n], n, t)) return n;
                    return -1;
                }, g.findNextWhere = function(t, e, a) {
                    null == a && (a = -1);
                    for (var n = a + 1; n < t.length; n++) {
                        var i = t[n];
                        if (e(i)) return i;
                    }
                }, g.findPreviousWhere = function(t, e, a) {
                    null == a && (a = t.length);
                    for (var n = a - 1; 0 <= n; n--) {
                        var i = t[n];
                        if (e(i)) return i;
                    }
                }, g.inherits = function(t) {
                    var e = this, a = t && t.hasOwnProperty("constructor") ? t.constructor : function() {
                        return e.apply(this, arguments);
                    }, n = function() {
                        this.constructor = a;
                    };
                    return n.prototype = e.prototype, a.prototype = new n(), a.extend = g.inherits, 
                    t && g.extend(a.prototype, t), a.__super__ = e.prototype, a;
                }, g.noop = function() {}, g.uid = (t = 0, function() {
                    return t++;
                }), g.isNumber = function(t) {
                    return !isNaN(parseFloat(t)) && isFinite(t);
                }, g.almostEquals = function(t, e, a) {
                    return Math.abs(t - e) < a;
                }, g.max = function(t) {
                    return t.reduce(function(t, e) {
                        return isNaN(e) ? t : Math.max(t, e);
                    }, Number.NEGATIVE_INFINITY);
                }, g.min = function(t) {
                    return t.reduce(function(t, e) {
                        return isNaN(e) ? t : Math.min(t, e);
                    }, Number.POSITIVE_INFINITY);
                }, g.sign = Math.sign ? function(t) {
                    return Math.sign(t);
                } : function(t) {
                    return 0 === (t = +t) || isNaN(t) ? t : 0 < t ? 1 : -1;
                }, g.log10 = Math.log10 ? function(t) {
                    return Math.log10(t);
                } : function(t) {
                    return Math.log(t) / Math.LN10;
                }, g.toRadians = function(t) {
                    return t * (Math.PI / 180);
                }, g.toDegrees = function(t) {
                    return t * (180 / Math.PI);
                }, g.getAngleFromPoint = function(t, e) {
                    var a = e.x - t.x, n = e.y - t.y, i = Math.sqrt(a * a + n * n), o = Math.atan2(n, a);
                    return o < -.5 * Math.PI && (o += 2 * Math.PI), {
                        angle: o,
                        distance: i
                    };
                }, g.distanceBetweenPoints = function(t, e) {
                    return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
                }, g.aliasPixel = function(t) {
                    return t % 2 == 0 ? 0 : .5;
                }, g.splineCurve = function(t, e, a, n) {
                    var i = t.skip ? e : t, o = e, r = a.skip ? e : a, l = Math.sqrt(Math.pow(o.x - i.x, 2) + Math.pow(o.y - i.y, 2)), s = Math.sqrt(Math.pow(r.x - o.x, 2) + Math.pow(r.y - o.y, 2)), d = l / (l + s), u = s / (l + s), c = n * (d = isNaN(d) ? 0 : d), h = n * (u = isNaN(u) ? 0 : u);
                    return {
                        previous: {
                            x: o.x - c * (r.x - i.x),
                            y: o.y - c * (r.y - i.y)
                        },
                        next: {
                            x: o.x + h * (r.x - i.x),
                            y: o.y + h * (r.y - i.y)
                        }
                    };
                }, g.EPSILON = Number.EPSILON || 1e-14, g.splineCurveMonotone = function(t) {
                    var e, a, n, i, o, r, l, s, d, u = (t || []).map(function(t) {
                        return {
                            model: t._model,
                            deltaK: 0,
                            mK: 0
                        };
                    }), c = u.length;
                    for (e = 0; e < c; ++e) (n = u[e]).model.skip || (a = 0 < e ? u[e - 1] : null, (i = e < c - 1 ? u[e + 1] : null) && !i.model.skip && (n.deltaK = (i.model.y - n.model.y) / (i.model.x - n.model.x)), 
                    !a || a.model.skip ? n.mK = n.deltaK : !i || i.model.skip ? n.mK = a.deltaK : this.sign(a.deltaK) !== this.sign(n.deltaK) ? n.mK = 0 : n.mK = (a.deltaK + n.deltaK) / 2);
                    for (e = 0; e < c - 1; ++e) n = u[e], i = u[e + 1], n.model.skip || i.model.skip || (g.almostEquals(n.deltaK, 0, this.EPSILON) ? n.mK = i.mK = 0 : (o = n.mK / n.deltaK, 
                    r = i.mK / n.deltaK, (s = Math.pow(o, 2) + Math.pow(r, 2)) <= 9 || (l = 3 / Math.sqrt(s), 
                    n.mK = o * l * n.deltaK, i.mK = r * l * n.deltaK)));
                    for (e = 0; e < c; ++e) (n = u[e]).model.skip || (a = 0 < e ? u[e - 1] : null, i = e < c - 1 ? u[e + 1] : null, 
                    a && !a.model.skip && (d = (n.model.x - a.model.x) / 3, n.model.controlPointPreviousX = n.model.x - d, 
                    n.model.controlPointPreviousY = n.model.y - d * n.mK), i && !i.model.skip && (d = (i.model.x - n.model.x) / 3, 
                    n.model.controlPointNextX = n.model.x + d, n.model.controlPointNextY = n.model.y + d * n.mK));
                }, g.nextItem = function(t, e, a) {
                    return a ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1];
                }, g.previousItem = function(t, e, a) {
                    return a ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1];
                }, g.niceNum = function(t, e) {
                    var a = Math.floor(g.log10(t)), n = t / Math.pow(10, a);
                    return (e ? n < 1.5 ? 1 : n < 3 ? 2 : n < 7 ? 5 : 10 : n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * Math.pow(10, a);
                };
                var a = g.easingEffects = {
                    linear: function(t) {
                        return t;
                    },
                    easeInQuad: function(t) {
                        return t * t;
                    },
                    easeOutQuad: function(t) {
                        return -1 * t * (t - 2);
                    },
                    easeInOutQuad: function(t) {
                        return (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
                    },
                    easeInCubic: function(t) {
                        return t * t * t;
                    },
                    easeOutCubic: function(t) {
                        return 1 * ((t = t / 1 - 1) * t * t + 1);
                    },
                    easeInOutCubic: function(t) {
                        return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
                    },
                    easeInQuart: function(t) {
                        return t * t * t * t;
                    },
                    easeOutQuart: function(t) {
                        return -1 * ((t = t / 1 - 1) * t * t * t - 1);
                    },
                    easeInOutQuart: function(t) {
                        return (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
                    },
                    easeInQuint: function(t) {
                        return 1 * (t /= 1) * t * t * t * t;
                    },
                    easeOutQuint: function(t) {
                        return 1 * ((t = t / 1 - 1) * t * t * t * t + 1);
                    },
                    easeInOutQuint: function(t) {
                        return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
                    },
                    easeInSine: function(t) {
                        return -1 * Math.cos(t / 1 * (Math.PI / 2)) + 1;
                    },
                    easeOutSine: function(t) {
                        return 1 * Math.sin(t / 1 * (Math.PI / 2));
                    },
                    easeInOutSine: function(t) {
                        return -.5 * (Math.cos(Math.PI * t / 1) - 1);
                    },
                    easeInExpo: function(t) {
                        return 0 === t ? 1 : 1 * Math.pow(2, 10 * (t / 1 - 1));
                    },
                    easeOutExpo: function(t) {
                        return 1 === t ? 1 : 1 * (1 - Math.pow(2, -10 * t / 1));
                    },
                    easeInOutExpo: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * --t));
                    },
                    easeInCirc: function(t) {
                        return 1 <= t ? t : -1 * (Math.sqrt(1 - (t /= 1) * t) - 1);
                    },
                    easeOutCirc: function(t) {
                        return 1 * Math.sqrt(1 - (t = t / 1 - 1) * t);
                    },
                    easeInOutCirc: function(t) {
                        return (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
                    },
                    easeInElastic: function(t) {
                        var e = 1.70158, a = 0, n = 1;
                        return 0 === t ? 0 : 1 == (t /= 1) ? 1 : (a || (a = .3), e = n < Math.abs(1) ? (n = 1, 
                        a / 4) : a / (2 * Math.PI) * Math.asin(1 / n), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / a));
                    },
                    easeOutElastic: function(t) {
                        var e = 1.70158, a = 0, n = 1;
                        return 0 === t ? 0 : 1 == (t /= 1) ? 1 : (a || (a = .3), e = n < Math.abs(1) ? (n = 1, 
                        a / 4) : a / (2 * Math.PI) * Math.asin(1 / n), n * Math.pow(2, -10 * t) * Math.sin((1 * t - e) * (2 * Math.PI) / a) + 1);
                    },
                    easeInOutElastic: function(t) {
                        var e = 1.70158, a = 0, n = 1;
                        return 0 === t ? 0 : 2 == (t /= .5) ? 1 : (a || (a = .3 * 1.5 * 1), e = n < Math.abs(1) ? (n = 1, 
                        a / 4) : a / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? n * Math.pow(2, 10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / a) * -.5 : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((1 * t - e) * (2 * Math.PI) / a) * .5 + 1);
                    },
                    easeInBack: function(t) {
                        return 1 * (t /= 1) * t * (2.70158 * t - 1.70158);
                    },
                    easeOutBack: function(t) {
                        return 1 * ((t = t / 1 - 1) * t * (2.70158 * t + 1.70158) + 1);
                    },
                    easeInOutBack: function(t) {
                        var e = 1.70158;
                        return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);
                    },
                    easeInBounce: function(t) {
                        return 1 - a.easeOutBounce(1 - t);
                    },
                    easeOutBounce: function(t) {
                        return (t /= 1) < 1 / 2.75 ? 7.5625 * t * t * 1 : t < 2 / 2.75 ? 1 * (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 * (7.5625 * (t -= 2.625 / 2.75) * t + .984375);
                    },
                    easeInOutBounce: function(t) {
                        return t < .5 ? .5 * a.easeInBounce(2 * t) : .5 * a.easeOutBounce(2 * t - 1) + .5;
                    }
                };
                g.requestAnimFrame = function(t) {
                    return setTimeout(t, 1e3 / 60);
                }, g.cancelAnimFrame = function(t) {
                    return clearTimeout(t, 1e3 / 60);
                }, g.getRelativePosition = function(t, e) {
                    var a, n, i = t.originalEvent || t, o = t.currentTarget || t.srcElement, r = o.getBoundingClientRect(), l = i.touches;
                    n = l && 0 < l.length ? (a = l[0].clientX, l[0].clientY) : (a = i.clientX, i.clientY);
                    var s = parseFloat(g.getStyle(o, "padding-left")), d = parseFloat(g.getStyle(o, "padding-top")), u = parseFloat(g.getStyle(o, "padding-right")), c = parseFloat(g.getStyle(o, "padding-bottom")), h = r.right - r.left - s - u, f = r.bottom - r.top - d - c;
                    return {
                        x: a = Math.round((a - r.left - s) / h * o.width / e.currentDevicePixelRatio),
                        y: n = Math.round((n - r.top - d) / f * o.height / e.currentDevicePixelRatio)
                    };
                }, g.addEvent = function(t, e, a) {
                    t.addEventListener ? t.addEventListener(e, a) : t.attachEvent ? t.attachEvent("on" + e, a) : t["on" + e] = a;
                }, g.removeEvent = function(t, e, a) {
                    t.removeEventListener ? t.removeEventListener(e, a, !1) : t.detachEvent ? t.detachEvent("on" + e, a) : t["on" + e] = g.noop;
                }, g.bindEvents = function(e, t, a) {
                    var n = e.events = e.events || {};
                    g.each(t, function(t) {
                        n[t] = function() {
                            a.apply(e, arguments);
                        }, g.addEvent(e.chart.canvas, t, n[t]);
                    });
                }, g.unbindEvents = function(t, e) {
                    var a = t.chart.canvas;
                    g.each(e, function(t, e) {
                        g.removeEvent(a, e, t);
                    });
                }, g.getConstraintWidth = function(t) {
                    return e(t, "max-width", "clientWidth");
                }, g.getConstraintHeight = function(t) {
                    return e(t, "max-height", "clientHeight");
                }, g.getMaximumWidth = function(t) {
                    return t.style.width;
                }, g.getMaximumHeight = function(t) {
                    return t.style.height;
                }, g.getStyle = function(t, e) {
                    return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e);
                }, g.retinaScale = function(t) {
                    var e = t.ctx, a = t.canvas, n = a.width, i = a.height, o = t.currentDevicePixelRatio = e.devicePixelRatio || 1;
                    1 !== o && (a.height = i * o, a.width = n * o, e.scale(o, o), t.originalDevicePixelRatio = t.originalDevicePixelRatio || o);
                }, g.clear = function(t) {
                    t.ctx.clearRect(0, 0, t.width, t.height);
                }, g.fontString = function(t, e, a) {
                    return e + " " + t + "px " + a;
                }, g.longestText = function(e, t, a, n) {
                    var i = (n = n || {}).data = n.data || {}, o = n.garbageCollect = n.garbageCollect || [];
                    n.font !== t && (i = n.data = {}, o = n.garbageCollect = [], n.font = t), e.font = t;
                    var r = 0;
                    g.each(a, function(t) {
                        null != t && !0 !== g.isArray(t) ? r = g.measureText(e, i, o, r, t) : g.isArray(t) && g.each(t, function(t) {
                            null == t || g.isArray(t) || (r = g.measureText(e, i, o, r, t));
                        });
                    });
                    var l = o.length / 2;
                    if (l > a.length) {
                        for (var s = 0; s < l; s++) delete i[o[s]];
                        o.splice(0, l);
                    }
                    return r;
                }, g.measureText = function(t, e, a, n, i) {
                    var o = e[i];
                    return o || (o = e[i] = t.measureText(i).width, a.push(i)), n < o && (n = o), n;
                }, g.numberOfLabelLines = function(t) {
                    var e = 1;
                    return g.each(t, function(t) {
                        g.isArray(t) && t.length > e && (e = t.length);
                    }), e;
                }, g.drawRoundedRectangle = function(t, e, a, n, i, o) {
                    t.beginPath(), t.moveTo(e + o, a), t.lineTo(e + n - o, a), t.quadraticCurveTo(e + n, a, e + n, a + o), 
                    t.lineTo(e + n, a + i - o), t.quadraticCurveTo(e + n, a + i, e + n - o, a + i), 
                    t.lineTo(e + o, a + i), t.quadraticCurveTo(e, a + i, e, a + i - o), t.lineTo(e, a + o), 
                    t.quadraticCurveTo(e, a, e + o, a), t.closePath();
                }, g.color = function(t) {
                    return n ? n(t) : (console.error("Color.js not found!"), t);
                }, g.addResizeListener = function(t, e) {}, g.removeResizeListener = function(t) {}, 
                g.isArray = Array.isArray ? function(t) {
                    return Array.isArray(t);
                } : function(t) {
                    return "[object Array]" === Object.prototype.toString.call(t);
                }, g.arrayEquals = function(t, e) {
                    var a, n, i, o;
                    if (!t || !e || t.length !== e.length) return !1;
                    for (a = 0, n = t.length; a < n; ++a) if (i = t[a], o = e[a], i instanceof Array && o instanceof Array) {
                        if (!g.arrayEquals(i, o)) return !1;
                    } else if (i !== o) return !1;
                    return !0;
                }, g.callCallback = function(t, e, a) {
                    t && "function" == typeof t.call && t.apply(a, e);
                }, g.getHoverColor = function(t) {
                    return g.color(t).saturate(.5).darken(.1).rgbString();
                };
            };
        }, {
            36: 36
        } ],
        21: [ function(t, e, a) {
            e.exports = function(t) {
                function s(t, e) {
                    var a, n, i, o, r;
                    for (n = 0, o = t.data.datasets.length; n < o; ++n) if (t.isDatasetVisible(n)) for (i = 0, 
                    r = (a = t.getDatasetMeta(n)).data.length; i < r; ++i) {
                        var l = a.data[i];
                        l._view.skip || e(l);
                    }
                }
                function r(t, e) {
                    var a = [];
                    return s(t, function(t) {
                        t.inRange(e.x, e.y) && a.push(t);
                    }), a;
                }
                function l(t, n, i, o) {
                    var r = Number.POSITIVE_INFINITY, l = [];
                    return o || (o = d.distanceBetweenPoints), s(t, function(t) {
                        if (!i || t.inRange(n.x, n.y)) {
                            var e = t.getCenterPoint(), a = o(n, e);
                            a < r ? (l = [ t ], r = a) : a === r && l.push(t);
                        }
                    }), l;
                }
                function a(n, t, e) {
                    var a = d.getRelativePosition(t, n.chart), i = e.intersect ? r(n, a) : l(n, a, !1, function(t, e) {
                        return Math.abs(t.x - e.x);
                    }), o = [];
                    return i.length ? (n.data.datasets.forEach(function(t, e) {
                        if (n.isDatasetVisible(e)) {
                            var a = n.getDatasetMeta(e).data[i[0]._index];
                            a && !a._view.skip && o.push(a);
                        }
                    }), o) : [];
                }
                var d = t.helpers;
                t.Interaction = {
                    modes: {
                        single: function(t, e) {
                            var a = d.getRelativePosition(e, t.chart), n = [];
                            return s(t, function(t) {
                                return t.inRange(a.x, a.y) ? (n.push(t), n) : void 0;
                            }), n.slice(0, 1);
                        },
                        label: a,
                        index: a,
                        dataset: function(t, e, a) {
                            var n = d.getRelativePosition(e, t.chart), i = a.intersect ? r(t, n) : l(t, n, !1);
                            return 0 < i.length && (i = t.getDatasetMeta(i[0]._datasetIndex).data), i;
                        },
                        "x-axis": function(t, e) {
                            return a(t, e, !0);
                        },
                        point: function(t, e) {
                            return r(t, d.getRelativePosition(e, t.chart));
                        },
                        nearest: function(t, e, a) {
                            var n = l(t, d.getRelativePosition(e, t.chart), a.intersect);
                            return 1 < n.length && n.sort(function(t, e) {
                                var a = t.getArea() - e.getArea();
                                return 0 === a && (a = t._datasetIndex - e._datasetIndex), a;
                            }), n.slice(0, 1);
                        },
                        x: function(t, e) {
                            var a = d.getRelativePosition(e, t.chart), n = [];
                            return s(t, function(t) {
                                t.inXRange(a.x) && n.push(t);
                            }), n;
                        },
                        y: function(t, e) {
                            var a = d.getRelativePosition(e, t.chart), n = [];
                            return s(t, function(t) {
                                t.inYRange(a.y) && n.push(t);
                            }), n;
                        }
                    }
                };
            };
        }, {} ],
        22: [ function(t, e, a) {
            e.exports = function() {
                var t = function t(e, a) {
                    return this.controller = new t.Controller(e, a, this), this.controller;
                };
                return t.defaults = {
                    global: {
                        responsive: !0,
                        responsiveAnimationDuration: 0,
                        maintainAspectRatio: !0,
                        events: [ "mousemove", "mouseout", "click", "touchstart", "touchmove" ],
                        hover: {
                            onHover: null,
                            mode: "nearest",
                            intersect: !0,
                            animationDuration: 400
                        },
                        onClick: null,
                        defaultColor: "rgba(0,0,0,0.1)",
                        defaultFontColor: "#666666",
                        defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                        defaultFontSize: 12,
                        defaultFontStyle: "normal",
                        showLines: !0,
                        elements: {},
                        legendCallback: function(t) {
                            var e = [];
                            e.push('<ul class="' + t.id + '-legend">');
                            for (var a = 0; a < t.data.datasets.length; a++) e.push('<li><span style="background-color:' + t.data.datasets[a].backgroundColor + '"></span>'), 
                            t.data.datasets[a].label && e.push(t.data.datasets[a].label), e.push("</li>");
                            return e.push("</ul>"), e.join("");
                        }
                    }
                }, t.Chart = t;
            };
        }, {} ],
        23: [ function(t, e, a) {
            e.exports = function(t) {
                var T = t.helpers;
                t.layoutService = {
                    defaults: {},
                    addBox: function(t, e) {
                        t.boxes || (t.boxes = []), t.boxes.push(e);
                    },
                    removeBox: function(t, e) {
                        t.boxes && t.boxes.splice(t.boxes.indexOf(e), 1);
                    },
                    update: function(e, a, t) {
                        function n(e) {
                            var t = T.findNextWhere(C, function(t) {
                                return t.box === e;
                            });
                            if (t) if (e.isHorizontal()) {
                                var a = {
                                    left: w,
                                    right: M,
                                    top: 0,
                                    bottom: 0
                                };
                                e.update(e.options.fullWidth ? m : k, b / 2, a);
                            } else e.update(t.minSize.width, S);
                        }
                        function i(t) {
                            t.isHorizontal() ? (t.left = t.options.fullWidth ? l : w, t.right = t.options.fullWidth ? a - s : w + k, 
                            t.top = _, t.bottom = _ + t.height, _ = t.bottom) : (t.left = F, t.right = F + t.width, 
                            t.top = D, t.bottom = D + S, F = t.right);
                        }
                        if (e) {
                            var o = e.options.layout, r = o ? o.padding : null, l = 0, s = 0, d = 0, u = 0;
                            u = isNaN(r) ? (l = r.left || 0, s = r.right || 0, d = r.top || 0, r.bottom || 0) : d = s = l = r;
                            var c = T.where(e.boxes, function(t) {
                                return "left" === t.options.position;
                            }), h = T.where(e.boxes, function(t) {
                                return "right" === t.options.position;
                            }), f = T.where(e.boxes, function(t) {
                                return "top" === t.options.position;
                            }), g = T.where(e.boxes, function(t) {
                                return "bottom" === t.options.position;
                            }), p = T.where(e.boxes, function(t) {
                                return "chartArea" === t.options.position;
                            });
                            f.sort(function(t, e) {
                                return (e.options.fullWidth ? 1 : 0) - (t.options.fullWidth ? 1 : 0);
                            }), g.sort(function(t, e) {
                                return (t.options.fullWidth ? 1 : 0) - (e.options.fullWidth ? 1 : 0);
                            });
                            var m = a - l - s, b = t - d - u, v = b / 2, x = (a - m / 2) / (c.length + h.length), y = (t - v) / (f.length + g.length), k = m, S = b, C = [];
                            T.each(c.concat(h, f, g), function(t) {
                                var e, a = t.isHorizontal();
                                a ? (e = t.update(t.options.fullWidth ? m : k, y), S -= e.height) : (e = t.update(x, v), 
                                k -= e.width), C.push({
                                    horizontal: a,
                                    minSize: e,
                                    box: t
                                });
                            });
                            var w = l, M = s, D = d, I = u;
                            T.each(c.concat(h), n), T.each(c, function(t) {
                                w += t.width;
                            }), T.each(h, function(t) {
                                M += t.width;
                            }), T.each(f.concat(g), n), T.each(f, function(t) {
                                D += t.height;
                            }), T.each(g, function(t) {
                                I += t.height;
                            }), T.each(c.concat(h), function(e) {
                                var t = T.findNextWhere(C, function(t) {
                                    return t.box === e;
                                }), a = {
                                    left: 0,
                                    right: 0,
                                    top: D,
                                    bottom: I
                                };
                                t && e.update(t.minSize.width, S, a);
                            }), w = l, M = s, D = d, I = u, T.each(c, function(t) {
                                w += t.width;
                            }), T.each(h, function(t) {
                                M += t.width;
                            }), T.each(f, function(t) {
                                D += t.height;
                            }), T.each(g, function(t) {
                                I += t.height;
                            });
                            var P = t - D - I, A = a - w - M;
                            (A !== k || P !== S) && (T.each(c, function(t) {
                                t.height = P;
                            }), T.each(h, function(t) {
                                t.height = P;
                            }), T.each(f, function(t) {
                                t.options.fullWidth || (t.width = A);
                            }), T.each(g, function(t) {
                                t.options.fullWidth || (t.width = A);
                            }), S = P, k = A);
                            var F = l, _ = d;
                            T.each(c.concat(f), i), F += k, _ += S, T.each(h, i), T.each(g, i), e.chartArea = {
                                left: w,
                                top: D,
                                right: w + k,
                                bottom: D + S
                            }, T.each(p, function(t) {
                                t.left = e.chartArea.left, t.top = e.chartArea.top, t.right = e.chartArea.right, 
                                t.bottom = e.chartArea.bottom, t.update(k, S);
                            });
                        }
                    }
                };
            };
        }, {} ],
        24: [ function(t, e, a) {
            e.exports = function(M) {
                function D(t, e) {
                    return t.usePointStyle ? e * Math.SQRT2 : t.boxWidth;
                }
                var I = M.helpers, t = I.noop;
                M.defaults.global.legend = {
                    display: !0,
                    displayFixed: !0,
                    position: "top",
                    fullWidth: !0,
                    reverse: !1,
                    onClick: function(t, e) {
                        var a = e.datasetIndex, n = this.chart, i = n.getDatasetMeta(a);
                        i.hidden = null === i.hidden ? !n.data.datasets[a].hidden : null, n.update();
                    },
                    onHover: null,
                    labels: {
                        boxWidth: 40,
                        padding: 10,
                        generateLabels: function(a) {
                            var t = a.data;
                            return I.isArray(t.datasets) ? t.datasets.map(function(t, e) {
                                return {
                                    text: t.label,
                                    fillStyle: I.isArray(t.backgroundColor) ? t.backgroundColor[0] : t.backgroundColor,
                                    hidden: !a.isDatasetVisible(e),
                                    lineCap: t.borderCapStyle,
                                    lineDash: t.borderDash,
                                    lineDashOffset: t.borderDashOffset,
                                    lineJoin: t.borderJoinStyle,
                                    lineWidth: t.borderWidth,
                                    strokeStyle: t.borderColor,
                                    pointStyle: t.pointStyle,
                                    datasetIndex: e
                                };
                            }, this) : [];
                        }
                    }
                }, M.Legend = M.Element.extend({
                    initialize: function(t) {
                        I.extend(this, t), this.legendHitBoxes = [], this.doughnutMode = !1;
                    },
                    beforeUpdate: t,
                    update: function(t, e, a) {
                        var n = this;
                        return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = a, n.beforeSetDimensions(), 
                        n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), 
                        n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize;
                    },
                    afterUpdate: t,
                    beforeSetDimensions: t,
                    setDimensions: function() {
                        var t = this;
                        t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, 
                        t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, 
                        t.paddingBottom = 0, t.minSize = {
                            width: 0,
                            height: 0
                        };
                    },
                    afterSetDimensions: t,
                    beforeBuildLabels: t,
                    buildLabels: function() {
                        var t = this;
                        t.legendItems = t.options.labels.generateLabels.call(t, t.chart), t.options.reverse && t.legendItems.reverse();
                    },
                    afterBuildLabels: t,
                    beforeFit: t,
                    fit: function() {
                        var n = this, t = n.options, i = t.labels, e = t.display, o = n.ctx, a = M.defaults.global, r = I.getValueOrDefault, l = r(i.fontSize, a.defaultFontSize), s = r(i.fontStyle, a.defaultFontStyle), d = r(i.fontFamily, a.defaultFontFamily), u = I.fontString(l, s, d), c = n.legendHitBoxes = [], h = n.minSize, f = n.isHorizontal();
                        if (h.height = f ? (h.width = n.maxWidth, e ? 10 : 0) : (h.width = e ? 10 : 0, n.maxHeight), 
                        e) if (o.font = u, o.setFontSize(l), f) {
                            var g = n.lineWidths = [ 0 ], p = n.legendItems.length ? l + i.padding : 0;
                            o.textAlign = "left", o.textBaseline = "top", I.each(n.legendItems, function(t, e) {
                                var a = D(i, l) + l / 2 + o.measureText(t.text).width;
                                g[g.length - 1] + a + i.padding >= n.width && (p += l + i.padding, g[g.length] = n.left), 
                                c[e] = {
                                    left: 0,
                                    top: 0,
                                    width: a,
                                    height: l
                                }, g[g.length - 1] += a + i.padding;
                            }), h.height += p;
                        } else {
                            var m = i.padding, b = n.columnWidths = [], v = i.padding, x = 0, y = 0, k = l + m;
                            I.each(n.legendItems, function(t, e) {
                                var a = D(i, l) + l / 2 + o.measureText(t.text).width;
                                y + k > h.height && (v += x + i.padding, b.push(x), y = x = 0), x = Math.max(x, a), 
                                y += k, c[e] = {
                                    left: 0,
                                    top: 0,
                                    width: a,
                                    height: l
                                };
                            }), v += x, b.push(x), h.width += v;
                        }
                        n.width = h.width, n.height = h.height;
                    },
                    afterFit: t,
                    isHorizontal: function() {
                        return "top" === this.options.position || "bottom" === this.options.position;
                    },
                    draw: function() {
                        var u = this, c = u.options, h = c.labels, f = M.defaults.global, g = f.elements.line, p = u.width, m = u.lineWidths;
                        if (c.display) {
                            var b, v = u.ctx, x = I.getValueOrDefault, t = x(h.fontColor, f.defaultFontColor), y = x(h.fontSize, f.defaultFontSize), e = x(h.fontStyle, f.defaultFontStyle), a = x(h.fontFamily, f.defaultFontFamily), n = I.fontString(y, e, a);
                            v.textAlign = "left", v.textBaseline = "top", v.setLineWidth(.5), v.setStrokeStyle(t), 
                            v.setFillStyle(t), v.font = n, v.setFontSize(y);
                            var k = D(h, y), S = u.legendHitBoxes, C = u.isHorizontal();
                            b = C ? {
                                x: u.left + (p - m[0]) / 2,
                                y: u.top + h.padding,
                                line: 0
                            } : {
                                x: u.left + h.padding,
                                y: u.top + h.padding,
                                line: 0
                            };
                            var w = y + h.padding;
                            I.each(u.legendItems, function(t, e) {
                                var a, n, i, o, r = v.measureText(t.text).width, l = k + y / 2 + r, s = b.x, d = b.y;
                                C ? p <= s + l && (d = b.y += w, b.line++, s = b.x = u.left + (p - m[b.line]) / 2) : d + w > u.bottom && (s = b.x = s + u.columnWidths[b.line] + h.padding, 
                                d = b.y = u.top, b.line++), function(t, e, a) {
                                    if (!(isNaN(k) || k <= 0) && c.displayFixed) {
                                        v.save(), v.setFillStyle(x(a.fillStyle, f.defaultColor)), v.setLineCap(x(a.lineCap, g.borderCapStyle)), 
                                        v.lineDashOffset = x(a.lineDashOffset, g.borderDashOffset), v.setLineJoin(x(a.lineJoin, g.borderJoinStyle)), 
                                        v.setLineWidth(x(a.lineWidth, g.borderWidth)), v.setStrokeStyle(x(a.strokeStyle, f.defaultColor));
                                        var n = 0 === x(a.lineWidth, g.borderWidth);
                                        if (v.setLineDash && v.setLineDash(x(a.lineDash, g.borderDash)), c.labels && c.labels.usePointStyle) {
                                            var i = y * Math.SQRT2 / 2, o = i / Math.SQRT2, r = t + o, l = e + o;
                                            M.canvasHelpers.drawPoint(v, a.pointStyle, i, r, l);
                                        } else n || v.strokeRect(t, e, k, y), v.fillRect(t, e, k, y);
                                        v.restore();
                                    }
                                }(s, d, t), S[e].left = s, S[e].top = d, a = s, n = d, i = t, o = r, v.fillText(i.text, k + y / 2 + a, n + 10), 
                                i.hidden && (v.beginPath(), v.setLineWidth(2), v.moveTo(k + y / 2 + a, n + y / 2), 
                                v.lineTo(k + y / 2 + a + o, n + y / 2), v.stroke()), C ? b.x += l + h.padding : b.y += w;
                            });
                        }
                    },
                    handleEvent: function(t) {
                        var e = this, a = e.options, n = "mouseup" === t.type ? "click" : t.type, i = !1;
                        if ("mousemove" === n) {
                            if (!a.onHover) return;
                        } else {
                            if ("click" !== n && "touchstart" != n) return;
                            if (!a.onClick) return;
                        }
                        var o = I.getRelativePosition(t, e.chart.chart), r = o.x, l = o.y;
                        if (r >= e.left && r <= e.right && l >= e.top && l <= e.bottom) for (var s = e.legendHitBoxes, d = 0; d < s.length; ++d) {
                            var u = s[d];
                            if (r >= u.left && r <= u.left + u.width && l >= u.top && l <= u.top + u.height) {
                                if ("click" === n || "touchstart" == n) {
                                    a.onClick.call(e, t, e.legendItems[d]), i = !0;
                                    break;
                                }
                                if ("mousemove" === n) {
                                    a.onHover.call(e, t, e.legendItems[d]), i = !0;
                                    break;
                                }
                            }
                        }
                        return i;
                    }
                }), M.plugins.register({
                    beforeInit: function(t) {
                        var e = t.options.legend;
                        e && (t.legend = new M.Legend({
                            ctx: t.chart.ctx,
                            options: e,
                            chart: t
                        }), M.layoutService.addBox(t, t.legend));
                    }
                });
            };
        }, {} ],
        25: [ function(t, e, a) {
            e.exports = function(t) {
                var e = t.helpers.noop;
                t.plugins = {
                    _plugins: [],
                    register: function(t) {
                        var e = this._plugins;
                        [].concat(t).forEach(function(t) {
                            -1 === e.indexOf(t) && e.push(t);
                        });
                    },
                    unregister: function(t) {
                        var a = this._plugins;
                        [].concat(t).forEach(function(t) {
                            var e = a.indexOf(t);
                            -1 !== e && a.splice(e, 1);
                        });
                    },
                    clear: function() {
                        this._plugins = [];
                    },
                    count: function() {
                        return this._plugins.length;
                    },
                    getAll: function() {
                        return this._plugins;
                    },
                    notify: function(t, e) {
                        var a, n, i = this._plugins, o = i.length;
                        for (a = 0; a < o; ++a) if ("function" == typeof (n = i[a])[t] && !1 === n[t].apply(n, e || [])) return !1;
                        return !0;
                    }
                }, t.PluginBase = t.Element.extend({
                    beforeInit: e,
                    afterInit: e,
                    beforeUpdate: e,
                    afterUpdate: e,
                    beforeDraw: e,
                    afterDraw: e,
                    destroy: e
                }), t.pluginService = t.plugins;
            };
        }, {} ],
        26: [ function(t, e, a) {
            e.exports = function(Y) {
                var U = Y.helpers;
                Y.defaults.scale = {
                    display: !0,
                    position: "left",
                    gridLines: {
                        display: !0,
                        color: "rgba(0, 0, 0, 0.1)",
                        lineWidth: 1,
                        drawBorder: !0,
                        drawOnChartArea: !0,
                        drawTicks: !0,
                        tickMarkLength: 10,
                        zeroLineWidth: 1,
                        zeroLineColor: "rgba(0,0,0,0.25)",
                        offsetGridLines: !1,
                        borderDash: [],
                        borderDashOffset: 0
                    },
                    scaleLabel: {
                        labelString: "",
                        display: !1
                    },
                    ticks: {
                        beginAtZero: !1,
                        minRotation: 0,
                        maxRotation: 50,
                        mirror: !1,
                        padding: 10,
                        reverse: !1,
                        display: !0,
                        autoSkip: !0,
                        autoSkipPadding: 0,
                        labelOffset: 0,
                        callback: Y.Ticks.formatters.values
                    }
                }, Y.Scale = Y.Element.extend({
                    beforeUpdate: function() {
                        U.callCallback(this.options.beforeUpdate, [ this ]);
                    },
                    update: function(t, e, a) {
                        var n = this;
                        return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = U.extend({
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }, a), n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeDataLimits(), 
                        n.determineDataLimits(), n.afterDataLimits(), n.beforeBuildTicks(), n.buildTicks(), 
                        n.afterBuildTicks(), n.beforeTickToLabelConversion(), n.convertTicksToLabels(), 
                        n.afterTickToLabelConversion(), n.beforeCalculateTickRotation(), n.calculateTickRotation(), 
                        n.afterCalculateTickRotation(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), 
                        n.minSize;
                    },
                    afterUpdate: function() {
                        U.callCallback(this.options.afterUpdate, [ this ]);
                    },
                    beforeSetDimensions: function() {
                        U.callCallback(this.options.beforeSetDimensions, [ this ]);
                    },
                    setDimensions: function() {
                        var t = this;
                        t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, 
                        t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, 
                        t.paddingBottom = 0;
                    },
                    afterSetDimensions: function() {
                        U.callCallback(this.options.afterSetDimensions, [ this ]);
                    },
                    beforeDataLimits: function() {
                        U.callCallback(this.options.beforeDataLimits, [ this ]);
                    },
                    determineDataLimits: U.noop,
                    afterDataLimits: function() {
                        U.callCallback(this.options.afterDataLimits, [ this ]);
                    },
                    beforeBuildTicks: function() {
                        U.callCallback(this.options.beforeBuildTicks, [ this ]);
                    },
                    buildTicks: U.noop,
                    afterBuildTicks: function() {
                        U.callCallback(this.options.afterBuildTicks, [ this ]);
                    },
                    beforeTickToLabelConversion: function() {
                        U.callCallback(this.options.beforeTickToLabelConversion, [ this ]);
                    },
                    convertTicksToLabels: function() {
                        var t = this.options.ticks;
                        this.ticks = this.ticks.map(t.userCallback || t.callback);
                    },
                    afterTickToLabelConversion: function() {
                        U.callCallback(this.options.afterTickToLabelConversion, [ this ]);
                    },
                    beforeCalculateTickRotation: function() {
                        U.callCallback(this.options.beforeCalculateTickRotation, [ this ]);
                    },
                    calculateTickRotation: function() {
                        var t = this, e = t.ctx, a = Y.defaults.global, n = t.options.ticks, i = U.getValueOrDefault(n.fontSize, a.defaultFontSize), o = U.getValueOrDefault(n.fontStyle, a.defaultFontStyle), r = U.getValueOrDefault(n.fontFamily, a.defaultFontFamily), l = U.fontString(i, o, r);
                        e.font = l, e.setFontSize(i);
                        var s, d = e.measureText(t.ticks[0]).width, u = e.measureText(t.ticks[t.ticks.length - 1]).width;
                        if (t.labelRotation = n.minRotation || 0, t.paddingRight = 0, t.paddingLeft = 0, 
                        t.options.display && t.isHorizontal()) {
                            t.paddingRight = u / 2 + 3, t.paddingLeft = d / 2 + 3, t.longestTextCache || (t.longestTextCache = {});
                            for (var c, h, f = U.longestText(e, l, t.ticks, t.longestTextCache), g = f, p = t.getPixelForTick(1) - t.getPixelForTick(0) - 6; p < g && t.labelRotation < n.maxRotation; ) {
                                if (c = Math.cos(U.toRadians(t.labelRotation)), h = Math.sin(U.toRadians(t.labelRotation)), 
                                (s = c * d) + i / 2 > t.yLabelWidth && (t.paddingLeft = s + i / 2), t.paddingRight = i / 2, 
                                h * f > t.maxHeight) {
                                    t.labelRotation--;
                                    break;
                                }
                                t.labelRotation++, g = c * f;
                            }
                        }
                        t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0));
                    },
                    afterCalculateTickRotation: function() {
                        U.callCallback(this.options.afterCalculateTickRotation, [ this ]);
                    },
                    beforeFit: function() {
                        U.callCallback(this.options.beforeFit, [ this ]);
                    },
                    fit: function() {
                        var t = this, e = t.minSize = {
                            width: 0,
                            height: 0
                        }, a = t.options, n = Y.defaults.global, i = a.ticks, o = a.scaleLabel, r = a.gridLines, l = a.display, s = t.isHorizontal(), d = U.getValueOrDefault(i.fontSize, n.defaultFontSize), u = U.getValueOrDefault(i.fontStyle, n.defaultFontStyle), c = U.getValueOrDefault(i.fontFamily, n.defaultFontFamily), h = U.fontString(d, u, c), f = U.getValueOrDefault(o.fontSize, n.defaultFontSize), g = a.gridLines.tickMarkLength;
                        if (e.width = s ? t.isFullWidth() ? t.maxWidth - t.margins.left - t.margins.right : t.maxWidth : l && r.drawTicks ? g : 0, 
                        e.height = s ? l && r.drawTicks ? g : 0 : t.maxHeight, o.display && l && (s ? e.height += 1.5 * f : e.width += 1.5 * f), 
                        i.display && l) {
                            t.longestTextCache || (t.longestTextCache = {});
                            var p = U.longestText(t.ctx, h, t.ticks, t.longestTextCache), m = U.numberOfLabelLines(t.ticks), b = .5 * d;
                            if (s) {
                                t.longestLabelWidth = p;
                                var v = Math.sin(U.toRadians(t.labelRotation)) * t.longestLabelWidth + d * m + b * m;
                                e.height = Math.min(t.maxHeight, e.height + v), t.ctx.font = h, t.ctx.setFontSize(d);
                                var x = t.ctx.measureTextXscale(t.ticks[0]).width, y = t.ctx.measureTextXscale(t.ticks[t.ticks.length - 1]).width, k = Math.cos(U.toRadians(t.labelRotation)), S = Math.sin(U.toRadians(t.labelRotation));
                                t.labelRotation = 0, t.labelRotation = 0, t.paddingLeft = 0 !== t.labelRotation ? k * x + 3 : x / 2 + 3, 
                                t.paddingRight = 0 !== t.labelRotation ? S * (d / 2) + 3 : y / 2 + 3;
                            } else {
                                var C = t.maxWidth - e.width;
                                i.mirror ? p = 0 : p += t.options.ticks.padding, p < C ? e.width += p : e.width = t.maxWidth, 
                                t.paddingTop = d / 2, t.paddingBottom = d / 2;
                            }
                        }
                        t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0), 
                        t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0), t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0)), 
                        t.width = e.width, t.height = e.height;
                    },
                    afterFit: function() {
                        U.callCallback(this.options.afterFit, [ this ]);
                    },
                    isHorizontal: function() {
                        return "top" === this.options.position || "bottom" === this.options.position;
                    },
                    isFullWidth: function() {
                        return this.options.fullWidth;
                    },
                    getRightValue: function(t) {
                        return null == t ? NaN : "number" != typeof t || isFinite(t) ? "object" == (void 0 === t ? "undefined" : m(t)) ? t instanceof Date || t.isValid ? t : this.getRightValue(this.isHorizontal() ? t.x : t.y) : t : NaN;
                    },
                    getLabelForIndex: U.noop,
                    getPixelForValue: U.noop,
                    getValueForPixel: U.noop,
                    getPixelForTick: function(t, e) {
                        var a = this;
                        if (a.isHorizontal()) {
                            var n = (a.width - (a.paddingLeft + a.paddingRight)) / Math.max(a.ticks.length - (a.options.gridLines.offsetGridLines ? 0 : 1), 1), i = n * t + a.paddingLeft;
                            return e && (i += n / 2), a.left + Math.round(i) + (a.isFullWidth() ? a.margins.left : 0);
                        }
                        var o = a.height - (a.paddingTop + a.paddingBottom);
                        return a.top + t * (o / (a.ticks.length - 1));
                    },
                    getPixelForDecimal: function(t) {
                        var e = this;
                        if (e.isHorizontal()) {
                            var a = (e.width - (e.paddingLeft + e.paddingRight)) * t + e.paddingLeft;
                            return e.left + Math.round(a) + (e.isFullWidth() ? e.margins.left : 0);
                        }
                        return e.top + t * e.height;
                    },
                    getBasePixel: function() {
                        var t = this.min, e = this.max;
                        return this.getPixelForValue(this.beginAtZero ? 0 : t < 0 && e < 0 ? e : 0 < t && 0 < e ? t : 0);
                    },
                    draw: function(x, o) {
                        var y = this, k = y.options;
                        if (k.display) {
                            var S, t, r = y.ctx, e = Y.defaults.global, C = k.ticks, w = k.gridLines, a = k.scaleLabel, M = 0 !== y.labelRotation, n = C.autoSkip, D = y.isHorizontal();
                            C.maxTicksLimit && (t = C.maxTicksLimit);
                            var i = U.getValueOrDefault(C.fontColor, e.defaultFontColor), l = U.getValueOrDefault(C.fontSize, e.defaultFontSize), s = U.getValueOrDefault(C.fontStyle, e.defaultFontStyle), d = U.getValueOrDefault(C.fontFamily, e.defaultFontFamily), u = U.fontString(l, s, d), I = w.tickMarkLength, P = U.getValueOrDefault(w.borderDash, e.borderDash), A = U.getValueOrDefault(w.borderDashOffset, e.borderDashOffset), c = U.getValueOrDefault(a.fontColor, e.defaultFontColor), h = U.getValueOrDefault(a.fontSize, e.defaultFontSize), f = U.getValueOrDefault(a.fontStyle, e.defaultFontStyle), g = U.getValueOrDefault(a.fontFamily, e.defaultFontFamily), p = U.fontString(h, f, g), F = U.toRadians(y.labelRotation), m = Math.cos(F), b = y.longestLabelWidth * m;
                            r.setFillStyle(i);
                            var _ = [];
                            if (D) {
                                if (S = !1, M && (b /= 2), (b + C.autoSkipPadding) * y.ticks.length > y.width - (y.paddingLeft + y.paddingRight) && (S = 1 + Math.floor((b + C.autoSkipPadding) * y.ticks.length / (y.width - (y.paddingLeft + y.paddingRight)))), 
                                t && y.ticks.length > t) for (;!S || y.ticks.length / (S || 1) > t; ) S || (S = 1), 
                                S += 1;
                                n || (S = !1);
                            }
                            var T = "right" === k.position ? y.left : y.right - I, R = "right" === k.position ? y.left + I : y.right, L = "bottom" === k.position ? y.top : y.bottom - I, V = "bottom" === k.position ? y.top + I : y.bottom;
                            if (U.each(y.ticks, function(t, e) {
                                if (null != t) {
                                    var a = y.ticks.length === e + 1;
                                    if ((!(1 < S && 0 < e % S || e % S == 0 && e + S >= y.ticks.length) || a) && null != t) {
                                        var n, i;
                                        i = e === (void 0 !== y.zeroLineIndex ? y.zeroLineIndex : 0) ? (n = w.zeroLineWidth, 
                                        w.zeroLineColor) : (n = U.getValueAtIndexOrDefault(w.lineWidth, e), U.getValueAtIndexOrDefault(w.color, e));
                                        var o, r, l, s, d, u, c, h, f, g, p = "middle", m = "middle";
                                        if (D) {
                                            M || (m = "top" === k.position ? "bottom" : "top"), p = M ? "right" : "center";
                                            var b = y.getPixelForTick(e) + U.aliasPixel(n);
                                            f = y.getPixelForTick(e, w.offsetGridLines) + C.labelOffset, g = M ? y.top + 12 : "top" === k.position ? y.bottom - I : y.top + I, 
                                            o = l = d = c = b, r = L, s = V, u = x.top, h = x.bottom;
                                        } else {
                                            p = "left" === k.position ? C.mirror ? (f = y.right + C.padding, "left") : (f = y.right - C.padding, 
                                            "right") : C.mirror ? (f = y.left - C.padding, "right") : (f = y.left + C.padding, 
                                            "left");
                                            var v = y.getPixelForTick(e);
                                            v += U.aliasPixel(n), g = y.getPixelForTick(e, w.offsetGridLines), o = T, l = R, 
                                            d = x.left, c = x.right, r = s = u = h = v;
                                        }
                                        _.push({
                                            tx1: o,
                                            ty1: r,
                                            tx2: l,
                                            ty2: s,
                                            x1: d,
                                            y1: u,
                                            x2: c,
                                            y2: h,
                                            labelX: f,
                                            labelY: g,
                                            glWidth: n,
                                            glColor: i,
                                            glBorderDash: P,
                                            glBorderDashOffset: A,
                                            rotation: -1 * F,
                                            label: t,
                                            textBaseline: m,
                                            textAlign: p
                                        });
                                    }
                                }
                            }), U.each(_, function(t) {
                                if (w.display && (r.save(), r.setLineWidth(t.glWidth), r.setStrokeStyle(t.glColor), 
                                r.setLineDash && (r.setLineDash(t.glBorderDash), r.lineDashOffset = t.glBorderDashOffset), 
                                r.beginPath(), w.drawTicks && (r.moveTo(t.tx1, t.ty1), r.lineTo(t.tx2, t.ty2)), 
                                w.drawOnChartArea && (r.moveTo(t.x1, t.y1), r.lineTo(t.x2, t.y2)), r.stroke(), r.restore()), 
                                C.display) {
                                    r.save(), r.translate(t.labelX, t.labelY), r.rotate(t.rotation), r.font = u, r.setFontSize(l), 
                                    r.textBaseline = t.textBaseline, r.textAlign = t.textAlign;
                                    var e = t.label;
                                    if (U.isArray(e)) for (var a = 0, n = -(e.length - 1) * l * .75; a < e.length; ++a) r.fillText("" + e[a], 0, n), 
                                    n += 1.5 * l; else {
                                        var i = (e + "").replace(/[^\x00-\xff]/g, "**").length;
                                        "y-axis-0" == o.id || "y-axis-1" == o.id ? r.fillText(e, -1 * (5 * i + 7), 4.4) : "y-axis-2" == o.id ? r.fillText(e, 5, 4.4) : r.fillText(e, -2.9 * i, 10);
                                    }
                                    r.restore();
                                }
                            }), a.display) {
                                var v, B, O = 0;
                                if (D) v = y.left + (y.right - y.left) / 2, B = "bottom" === k.position ? y.bottom - h / 2 : y.top + h / 2; else {
                                    var W = "left" === k.position;
                                    v = W ? y.left + h / 2 : y.right - h / 2, B = y.top + (y.bottom - y.top) / 2, O = W ? -.5 * Math.PI : .5 * Math.PI;
                                }
                                r.save(), r.translate(v, B), r.rotate(O), r.textAlign = "center", r.textBaseline = "middle", 
                                r.setFillStyle(c), r.font = p, r.setFontSize(h), r.fillText(a.labelString, 0, 0), 
                                r.restore();
                            }
                            if (w.drawBorder) {
                                var z = U.getValueAtIndexOrDefault(w.lineWidth, 0);
                                r.setLineWidth(z), r.setStrokeStyle(U.getValueAtIndexOrDefault(w.color, 0));
                                var N = y.left, E = y.right, H = y.top, q = y.bottom, j = U.aliasPixel(z);
                                D ? (H = q = "top" === k.position ? y.bottom : y.top, H += j, q += j) : (N = E = "left" === k.position ? y.right : y.left, 
                                N += j, E += j), D && !w.hideX && (r.beginPath(), r.moveTo(N, H), r.lineTo(E, q), 
                                r.stroke()), D || w.hideY || (r.beginPath(), r.moveTo(N, H), r.lineTo(E, q), r.stroke());
                            }
                        }
                    }
                });
            };
        }, {} ],
        27: [ function(t, e, a) {
            e.exports = function(a) {
                var n = a.helpers;
                a.scaleService = {
                    constructors: {},
                    defaults: {},
                    registerScaleType: function(t, e, a) {
                        this.constructors[t] = e, this.defaults[t] = n.clone(a);
                    },
                    getScaleConstructor: function(t) {
                        return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0;
                    },
                    getScaleDefaults: function(t) {
                        return this.defaults.hasOwnProperty(t) ? n.scaleMerge(a.defaults.scale, this.defaults[t]) : {};
                    },
                    updateScaleDefaults: function(t, e) {
                        var a = this.defaults;
                        a.hasOwnProperty(t) && (a[t] = n.extend(a[t], e));
                    },
                    addScalesToLayout: function(e) {
                        n.each(e.scales, function(t) {
                            a.layoutService.addBox(e, t);
                        });
                    }
                };
            };
        }, {} ],
        28: [ function(t, e, a) {
            e.exports = function(t) {
                var d = t.helpers;
                t.Ticks = {
                    generators: {
                        linear: function(t, e) {
                            var a, n = [];
                            if (t.stepSize && 0 < t.stepSize) a = t.stepSize; else {
                                var i = d.niceNum(e.max - e.min, !1);
                                a = d.niceNum(i / (t.maxTicks - 1), !0);
                            }
                            var o = Math.floor(e.min / a) * a, r = Math.ceil(e.max / a) * a;
                            t.min && t.max && t.stepSize && ((t.max - t.min) % t.stepSize == 0 && (o = t.min, 
                            r = t.max));
                            var l = (r - o) / a;
                            l = d.almostEquals(l, Math.round(l), a / 1e3) ? Math.round(l) : Math.ceil(l), n.push(void 0 !== t.min ? t.min : o);
                            for (var s = 1; s < l; ++s) n.push(o + s * a);
                            return n.push(void 0 !== t.max ? t.max : r), n;
                        },
                        logarithmic: function(t, e) {
                            for (var a = [], n = d.getValueOrDefault, i = n(t.min, Math.pow(10, Math.floor(d.log10(e.min)))); i < e.max; ) {
                                var o, r;
                                a.push(i), 10 === (r = 0 === i ? (o = Math.floor(d.log10(e.minNotZero)), Math.round(e.minNotZero / Math.pow(10, o))) : (o = Math.floor(d.log10(i)), 
                                Math.floor(i / Math.pow(10, o)) + 1)) && (r = 1, ++o), i = r * Math.pow(10, o);
                            }
                            var l = n(t.max, i);
                            return a.push(l), a;
                        }
                    },
                    formatters: {
                        values: function(t) {
                            return d.isArray(t) ? t : "" + t;
                        },
                        linear: function(t, e, a) {
                            var n = 3 < a.length ? a[2] - a[1] : a[1] - a[0];
                            1 < Math.abs(n) && t !== Math.floor(t) && (n = t - Math.floor(t));
                            var i = d.log10(Math.abs(n)), o = "";
                            if (0 !== t) {
                                var r = -1 * Math.floor(i);
                                r = Math.max(Math.min(r, 20), 0), o = t.toFixed(r);
                            } else o = "0";
                            return o;
                        },
                        logarithmic: function(t, e, a) {
                            var n = t / Math.pow(10, Math.floor(d.log10(t)));
                            return 0 === t ? "0" : 1 === n || 2 === n || 5 === n || 0 === e || e === a.length - 1 ? t.toExponential() : "";
                        }
                    }
                };
            };
        }, {} ],
        29: [ function(t, e, a) {
            e.exports = function(v) {
                var x = v.helpers;
                v.defaults.global.title = {
                    display: !1,
                    position: "top",
                    fullWidth: !0,
                    fontStyle: "bold",
                    padding: 10,
                    text: ""
                };
                var t = x.noop;
                v.Title = v.Element.extend({
                    initialize: function(t) {
                        x.extend(this, t), this.options = x.configMerge(v.defaults.global.title, t.options), 
                        this.legendHitBoxes = [];
                    },
                    beforeUpdate: function() {
                        var t = this.chart.options;
                        t && t.title && (this.options = x.configMerge(v.defaults.global.title, t.title));
                    },
                    update: function(t, e, a) {
                        var n = this;
                        return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = a, n.beforeSetDimensions(), 
                        n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), 
                        n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize;
                    },
                    afterUpdate: t,
                    beforeSetDimensions: t,
                    setDimensions: function() {
                        var t = this;
                        t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, 
                        t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, 
                        t.paddingBottom = 0, t.minSize = {
                            width: 0,
                            height: 0
                        };
                    },
                    afterSetDimensions: t,
                    beforeBuildLabels: t,
                    buildLabels: t,
                    afterBuildLabels: t,
                    beforeFit: t,
                    fit: function() {
                        var t = this, e = x.getValueOrDefault, a = t.options, n = v.defaults.global, i = a.display, o = e(a.fontSize, n.defaultFontSize), r = t.minSize;
                        t.isHorizontal() ? (r.width = t.maxWidth, r.height = i ? o + 2 * a.padding : 0) : (r.width = i ? o + 2 * a.padding : 0, 
                        r.height = t.maxHeight), t.width = r.width, t.height = r.height;
                    },
                    afterFit: t,
                    isHorizontal: function() {
                        var t = this.options.position;
                        return "top" === t || "bottom" === t;
                    },
                    draw: function() {
                        var t = this, e = t.ctx, a = x.getValueOrDefault, n = t.options, i = v.defaults.global;
                        if (n.display) {
                            var o, r, l, s = a(n.fontSize, i.defaultFontSize), d = a(n.fontStyle, i.defaultFontStyle), u = a(n.fontFamily, i.defaultFontFamily), c = x.fontString(s, d, u), h = 0, f = t.top, g = t.left, p = t.bottom, m = t.right;
                            e.setFillStyle(a(n.fontColor, i.defaultFontColor)), e.font = c, e.setFontSize(s), 
                            t.isHorizontal() ? (o = g + (m - g) / 2, r = f + (p - f) / 2, l = m - g) : (o = "left" === n.position ? g + s / 2 : m - s / 2, 
                            r = f + (p - f) / 2, l = p - f, h = Math.PI * ("left" === n.position ? -.5 : .5)), 
                            e.save(), e.translate(o, r), e.rotate(h), e.textAlign = "center", e.textBaseline = "middle";
                            var b = -2.9 * (n.text + "").replace(/[^\x00-\xff]/g, "**").length;
                            e.fillText(n.text, b, 0, l), e.restore();
                        }
                    }
                }), v.plugins.register({
                    beforeInit: function(t) {
                        var e = t.options.title;
                        e && (t.titleBlock = new v.Title({
                            ctx: t.chart.ctx,
                            options: e,
                            chart: t
                        }), v.layoutService.addBox(t, t.titleBlock));
                    }
                });
            };
        }, {} ],
        30: [ function(t, e, a) {
            e.exports = function(R) {
                function x(t, e) {
                    var a = V.color(t);
                    return a.alpha(e * a.alpha()).rgbaString();
                }
                function r(t, e) {
                    return e && (V.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;
                }
                function L(t) {
                    var e = R.defaults.global, a = V.getValueOrDefault;
                    return {
                        xPadding: t.xPadding,
                        yPadding: t.yPadding,
                        xAlign: t.xAlign,
                        yAlign: t.yAlign,
                        bodyFontColor: t.bodyFontColor,
                        _bodyFontFamily: a(t.bodyFontFamily, e.defaultFontFamily),
                        _bodyFontStyle: a(t.bodyFontStyle, e.defaultFontStyle),
                        _bodyAlign: t.bodyAlign,
                        bodyFontSize: a(t.bodyFontSize, e.defaultFontSize),
                        bodySpacing: t.bodySpacing,
                        titleFontColor: t.titleFontColor,
                        _titleFontFamily: a(t.titleFontFamily, e.defaultFontFamily),
                        _titleFontStyle: a(t.titleFontStyle, e.defaultFontStyle),
                        titleFontSize: a(t.titleFontSize, e.defaultFontSize),
                        _titleAlign: t.titleAlign,
                        titleSpacing: t.titleSpacing,
                        titleMarginBottom: t.titleMarginBottom,
                        footerFontColor: t.footerFontColor,
                        _footerFontFamily: a(t.footerFontFamily, e.defaultFontFamily),
                        _footerFontStyle: a(t.footerFontStyle, e.defaultFontStyle),
                        footerFontSize: a(t.footerFontSize, e.defaultFontSize),
                        _footerAlign: t.footerAlign,
                        footerSpacing: t.footerSpacing,
                        footerMarginTop: t.footerMarginTop,
                        caretSize: t.caretSize,
                        cornerRadius: t.cornerRadius,
                        backgroundColor: t.backgroundColor,
                        opacity: 0,
                        legendColorBackground: t.multiKeyBackground,
                        displayColors: t.displayColors
                    };
                }
                var V = R.helpers;
                R.defaults.global.tooltips = {
                    enabled: !0,
                    custom: null,
                    mode: "nearest",
                    position: "average",
                    intersect: !0,
                    backgroundColor: "rgba(0,0,0,0.8)",
                    titleFontStyle: "bold",
                    titleSpacing: 2,
                    titleMarginBottom: 6,
                    titleFontColor: "#ffffff",
                    titleAlign: "left",
                    bodySpacing: 2,
                    bodyFontColor: "#ffffff",
                    bodyAlign: "left",
                    footerFontStyle: "bold",
                    footerSpacing: 2,
                    footerMarginTop: 6,
                    footerFontColor: "#ffffff",
                    footerAlign: "left",
                    yPadding: 6,
                    xPadding: 6,
                    caretSize: 5,
                    cornerRadius: 6,
                    multiKeyBackground: "#ffffff",
                    displayColors: !0,
                    callbacks: {
                        beforeTitle: V.noop,
                        title: function(t, e) {
                            var a = "", n = e.labels, i = n ? n.length : 0;
                            if (0 < t.length) {
                                var o = t[0];
                                o.xLabel ? a = o.xLabel : 0 < i && o.index < i && (a = n[o.index]);
                            }
                            return a;
                        },
                        afterTitle: V.noop,
                        beforeBody: V.noop,
                        beforeLabel: V.noop,
                        label: function(t, e) {
                            return (e.datasets[t.datasetIndex].label || "") + ": " + t.yLabel;
                        },
                        labelColor: function(t, e) {
                            var a = e.getDatasetMeta(t.datasetIndex).data[t.index]._view;
                            return {
                                borderColor: a.borderColor,
                                backgroundColor: a.backgroundColor
                            };
                        },
                        afterLabel: V.noop,
                        afterBody: V.noop,
                        beforeFooter: V.noop,
                        footer: V.noop,
                        afterFooter: V.noop
                    }
                }, R.Tooltip = R.Element.extend({
                    initialize: function() {
                        this._model = L(this._options);
                    },
                    getTitle: function() {
                        var t = this._options.callbacks, e = t.beforeTitle.apply(this, arguments), a = t.title.apply(this, arguments), n = t.afterTitle.apply(this, arguments), i = [];
                        return r(i = r(i = r(i, e), a), n);
                    },
                    getBeforeBody: function() {
                        var t = this._options.callbacks.beforeBody.apply(this, arguments);
                        return V.isArray(t) ? t : void 0 !== t ? [ t ] : [];
                    },
                    getBody: function(t, a) {
                        var n = this, i = n._options.callbacks, o = [];
                        return V.each(t, function(t) {
                            var e = {
                                before: [],
                                lines: [],
                                after: []
                            };
                            r(e.before, i.beforeLabel.call(n, t, a)), r(e.lines, i.label.call(n, t, a)), r(e.after, i.afterLabel.call(n, t, a)), 
                            o.push(e);
                        }), o;
                    },
                    getAfterBody: function() {
                        var t = this._options.callbacks.afterBody.apply(this, arguments);
                        return V.isArray(t) ? t : void 0 !== t ? [ t ] : [];
                    },
                    getFooter: function() {
                        var t = this._options.callbacks, e = t.beforeFooter.apply(this, arguments), a = t.footer.apply(this, arguments), n = t.afterFooter.apply(this, arguments), i = [];
                        return r(i = r(i = r(i, e), a), n);
                    },
                    update: function(t) {
                        var e, a, n, i, o, r, l, s, d, u, c, h, f, g, p, m, b, v, x, y = this, k = y._options, S = y._model, C = y._model = L(k), w = y._active, M = y._data, D = y._chartInstance, I = {
                            xAlign: S.xAlign,
                            yAlign: S.yAlign
                        }, P = {
                            x: S.x,
                            y: S.y
                        }, A = {
                            width: S.width,
                            height: S.height
                        }, F = {
                            x: S.caretX,
                            y: S.caretY
                        };
                        if (w.length) {
                            C.opacity = 1;
                            var _ = [];
                            F = R.Tooltip.positioners[k.position](w, y._eventPosition);
                            var T = [];
                            for (e = 0, a = w.length; e < a; ++e) T.push((p = w[e], b = m = void 0, m = p._xScale, 
                            b = p._yScale || p._scale, v = p._index, x = p._datasetIndex, {
                                xLabel: m ? m.getLabelForIndex(v, x) : "",
                                yLabel: b ? b.getLabelForIndex(v, x) : "",
                                index: v,
                                datasetIndex: x,
                                x: p._model.x,
                                y: p._model.y
                            }));
                            k.filter && (T = T.filter(function(t) {
                                return k.filter(t, M);
                            })), k.itemSort && (T = T.sort(function(t, e) {
                                return k.itemSort(t, e, M);
                            })), V.each(T, function(t) {
                                _.push(k.callbacks.labelColor.call(y, t, D));
                            }), C.title = y.getTitle(T, M), C.beforeBody = y.getBeforeBody(T, M), C.body = y.getBody(T, M), 
                            C.afterBody = y.getAfterBody(T, M), C.footer = y.getFooter(T, M), C.x = Math.round(F.x), 
                            C.y = Math.round(F.y), C.caretPadding = V.getValueOrDefault(F.padding, 2), C.labelColors = _, 
                            C.dataPoints = T, I = function(t, e) {
                                var a = t._model, n = t._chart, i = t._chartInstance.chartArea, o = "center", r = "center";
                                a.y < e.height ? r = "top" : a.y > n.height - e.height && (r = "bottom");
                                var l, s, d, u, c, h = (i.left + i.right) / 2, f = (i.top + i.bottom) / 2;
                                s = "center" === r ? (l = function(t) {
                                    return t <= h;
                                }, function(t) {
                                    return h < t;
                                }) : (l = function(t) {
                                    return t <= e.width / 2;
                                }, function(t) {
                                    return t >= n.width - e.width / 2;
                                }), d = function(t) {
                                    return t + e.width > n.width;
                                }, u = function(t) {
                                    return t - e.width < 0;
                                }, c = function(t) {
                                    return t <= f ? "top" : "bottom";
                                }, l(a.x) ? (o = "left", d(a.x) && (o = "center", r = c(a.y))) : s(a.x) && (o = "right", 
                                u(a.x) && (o = "center", r = c(a.y)));
                                var g = t._options;
                                return {
                                    xAlign: g.xAlign ? g.xAlign : o,
                                    yAlign: g.yAlign ? g.yAlign : r
                                };
                            }(this, A = function(t, e) {
                                var a = t._chart.ctx, n = 2 * e.yPadding, i = 0, o = e.body, r = o.reduce(function(t, e) {
                                    return t + e.before.length + e.lines.length + e.after.length;
                                }, 0);
                                r += e.beforeBody.length + e.afterBody.length;
                                var l = e.title.length, s = e.footer.length, d = e.titleFontSize, u = e.bodyFontSize, c = e.footerFontSize;
                                n += l * d, n += l ? (l - 1) * e.titleSpacing : 0, n += l ? e.titleMarginBottom : 0, 
                                n += r * u, n += r ? (r - 1) * e.bodySpacing : 0, n += s ? e.footerMarginTop : 0, 
                                n += s * c, n += s ? (s - 1) * e.footerSpacing : 0;
                                var h = 0, f = function(t) {
                                    i = Math.max(i, a.measureTextToolTip(t).width + h);
                                };
                                return a.font = V.fontString(d, e._titleFontStyle, e._titleFontFamily), a.setFontSize(d), 
                                V.each(e.title, f), a.font = V.fontString(u, e._bodyFontStyle, e._bodyFontFamily), 
                                a.setFontSize(u), V.each(e.beforeBody.concat(e.afterBody), f), h = e.displayColors ? u + 2 : 0, 
                                V.each(o, function(t) {
                                    V.each(t.before, f), V.each(t.lines, f), V.each(t.after, f);
                                }), h = 0, a.font = V.fontString(c, e._footerFontStyle, e._footerFontFamily), a.setFontSize(c), 
                                V.each(e.footer, f), {
                                    width: i += 2 * e.xPadding,
                                    height: n
                                };
                            }(this, C)), i = A, o = I, r = (n = C).x, l = n.y, s = n.caretSize, d = n.caretPadding, 
                            u = n.cornerRadius, c = o.xAlign, h = o.yAlign, f = s + d, g = u + d, "right" === c ? r -= i.width : "center" === c && (r -= i.width / 2), 
                            "top" === h ? l += f : l -= "bottom" === h ? i.height + f : i.height / 2, "center" === h ? "left" === c ? r += f : "right" === c && (r -= f) : "left" === c ? r -= g : "right" === c && (r += g), 
                            P = {
                                x: r,
                                y: l
                            };
                        } else C.opacity = 0;
                        return C.xAlign = I.xAlign, C.yAlign = I.yAlign, C.x = P.x, C.y = P.y, C.width = A.width, 
                        C.height = A.height, C.caretX = F.x, C.caretY = F.y, y._model = C, t && k.custom && k.custom.call(y, C), 
                        y;
                    },
                    drawCaret: function(t, e, a) {
                        var n, i, o, r, l, s, d = this._view, u = this._chart.ctx, c = d.caretSize, h = d.cornerRadius, f = d.xAlign, g = d.yAlign, p = t.x, m = t.y, b = e.width, v = e.height;
                        s = "center" === g ? (o = (i = "left" === f ? (n = p) - c : (n = p + b) + c, n), 
                        r = (l = m + v / 2) - c, l + c) : (o = "left" === f ? (i = (n = p + h) + c) + c : "right" === f ? (i = (n = p + b - h) - c) - c : (n = (i = p + b / 2) - c, 
                        i + c), l = "top" === g ? (r = m) - c : (r = m + v) + c, r), u.setFillStyle(x(d.backgroundColor, a)), 
                        u.beginPath(), u.moveTo(n, r), u.lineTo(i, l), u.lineTo(o, s), u.closePath(), u.fill();
                    },
                    drawTitle: function(t, e, a, n) {
                        var i = e.title;
                        if (i.length) {
                            a.textAlign = e._titleAlign, a.textBaseline = "top";
                            var o = e.titleFontSize, r = e.titleSpacing;
                            a.setFillStyle(x(e.titleFontColor, n)), a.font = V.fontString(o, e._titleFontStyle, e._titleFontFamily), 
                            a.setFontSize(o);
                            var l, s, d = 8;
                            for (e.displayColors || (d = 13), l = 0, s = i.length; l < s; ++l) a.fillText(i[l], t.x, t.y + d), 
                            t.y += o + r, l + 1 === i.length && (t.y += e.titleMarginBottom - r);
                        }
                    },
                    drawBody: function(a, n, i, o) {
                        var r = n.bodyFontSize, e = n.bodySpacing, t = n.body;
                        i.textAlign = n._bodyAlign, i.textBaseline = "top";
                        var l = x(n.bodyFontColor, o);
                        i.setFillStyle(l), i.font = V.fontString(r, n._bodyFontStyle, n._bodyFontFamily), 
                        i.setFontSize(r);
                        var s = 0, d = function(t) {
                            i.fillText(t, a.x + s, a.y + 10), a.y += r + e;
                        };
                        V.each(n.beforeBody, d);
                        var u = n.displayColors;
                        s = u ? r + 2 : 0, V.each(t, function(t, e) {
                            V.each(t.before, d), V.each(t.lines, function(t) {
                                u && (i.setFillStyle(x(n.legendColorBackground, o)), i.fillRect(a.x, a.y, r, r), 
                                i.setStrokeStyle(x(n.labelColors[e].borderColor, o)), i.strokeRect(a.x, a.y, r, r), 
                                i.setFillStyle(x(n.labelColors[e].backgroundColor, o)), i.fillRect(a.x + 1, a.y + 1, r - 2, r - 2), 
                                i.setFillStyle(l)), d(t);
                            }), V.each(t.after, d);
                        }), s = 0, V.each(n.afterBody, d), a.y -= e;
                    },
                    drawFooter: function(e, a, n, t) {
                        var i = a.footer;
                        i.length && (e.y += a.footerMarginTop, n.textAlign = a._footerAlign, n.textBaseline = "top", 
                        n.setFillStyle(x(a.footerFontColor, t)), n.font = V.fontString(a.footerFontSize, a._footerFontStyle, a._footerFontFamily), 
                        n.setFontSize(a.footerFontSize), V.each(i, function(t) {
                            n.fillText(t, e.x, e.y), e.y += a.footerFontSize + a.footerSpacing;
                        }));
                    },
                    drawBackground: function(t, e, a, n, i) {
                        a.setFillStyle(x(e.backgroundColor, i)), V.drawRoundedRectangle(a, t.x, t.y, n.width, n.height, e.cornerRadius), 
                        a.fill();
                    },
                    draw: function() {
                        var t = this._chart.ctx, e = this._view;
                        if (0 !== e.opacity) {
                            var a = {
                                width: e.width,
                                height: e.height
                            }, n = {
                                x: e.x,
                                y: e.y
                            }, i = Math.abs(e.opacity < .001) ? 0 : e.opacity;
                            this._options.enabled && (this.drawBackground(n, e, t, a, i), this.drawCaret(n, a, i), 
                            n.x += e.xPadding, n.y += e.yPadding, this.drawTitle(n, e, t, i), this.drawBody(n, e, t, i), 
                            this.drawFooter(n, e, t, i));
                        }
                    },
                    handleEvent: function(t) {
                        var e = this, a = e._options, n = !1;
                        if (e._lastActive = e._lastActive || [], "mouseout" === t.type ? e._active = [] : e._active = e._chartInstance.getElementsAtEventForMode(t, a.mode, a), 
                        n = !V.arrayEquals(e._active, e._lastActive), e._lastActive = e._active, a.enabled || a.custom) {
                            e._eventPosition = V.getRelativePosition(t, e._chart);
                            var i = e._model;
                            e.update(!0), e.pivot(), n |= i.x !== e._model.x || i.y !== e._model.y;
                        }
                        return n;
                    }
                }), R.Tooltip.positioners = {
                    average: function(t) {
                        if (!t.length) return !1;
                        var e, a, n = 0, i = 0, o = 0;
                        for (e = 0, a = t.length; e < a; ++e) {
                            var r = t[e];
                            if (r && r.hasValue()) {
                                var l = r.tooltipPosition();
                                n += l.x, i += l.y, ++o;
                            }
                        }
                        return {
                            x: Math.round(n / o),
                            y: Math.round(i / o)
                        };
                    },
                    nearest: function(t, e) {
                        var a, n, i, o = e.x, r = e.y, l = Number.POSITIVE_INFINITY;
                        for (n = 0, i = t.length; n < i; ++n) {
                            var s = t[n];
                            if (s && s.hasValue()) {
                                var d = s.getCenterPoint(), u = V.distanceBetweenPoints(e, d);
                                u < l && (l = u, a = s);
                            }
                        }
                        if (a) {
                            var c = a.tooltipPosition();
                            o = c.x, r = c.y;
                        }
                        return {
                            x: o,
                            y: r
                        };
                    }
                };
            };
        }, {} ],
        31: [ function(t, e, a) {
            e.exports = function(t) {
                var u = t.helpers, e = t.defaults.global;
                e.elements.arc = {
                    backgroundColor: e.defaultColor,
                    borderColor: "#ffffff",
                    borderWidth: 2
                }, t.elements.Arc = t.Element.extend({
                    inLabelRange: function(t) {
                        var e = this._view;
                        return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2);
                    },
                    inRange: function(t, e) {
                        var a = this._view;
                        if (a) {
                            for (var n = u.getAngleFromPoint(a, {
                                x: t,
                                y: e
                            }), i = n.angle, o = n.distance, r = a.startAngle, l = a.endAngle; l < r; ) l += 2 * Math.PI;
                            for (;l < i; ) i -= 2 * Math.PI;
                            for (;i < r; ) i += 2 * Math.PI;
                            var s = r <= i && i <= l, d = o >= a.innerRadius && o <= a.outerRadius;
                            return s && d;
                        }
                        return !1;
                    },
                    getCenterPoint: function() {
                        var t = this._view, e = (t.startAngle + t.endAngle) / 2, a = (t.innerRadius + t.outerRadius) / 2;
                        return {
                            x: t.x + Math.cos(e) * a,
                            y: t.y + Math.sin(e) * a
                        };
                    },
                    getArea: function() {
                        var t = this._view;
                        return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2));
                    },
                    tooltipPosition: function() {
                        var t = this._view, e = t.startAngle + (t.endAngle - t.startAngle) / 2, a = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius;
                        return {
                            x: t.x + Math.cos(e) * a,
                            y: t.y + Math.sin(e) * a
                        };
                    },
                    draw: function() {
                        var t = this._chart.ctx, e = this._view, a = e.startAngle, n = e.endAngle;
                        t.beginPath(), t.arc(e.x, e.y, e.outerRadius, a, n), t.arc(e.x, e.y, e.innerRadius, n, a, !0), 
                        t.closePath(), t.setStrokeStyle(e.borderColor), t.setLineWidth(e.borderWidth), t.setFillStyle(e.backgroundColor), 
                        t.fill(), t.setLineJoin("bevel"), e.borderWidth && t.stroke();
                    }
                });
            };
        }, {} ],
        32: [ function(t, e, a) {
            e.exports = function(t) {
                var f = t.helpers, g = t.defaults.global;
                t.defaults.global.elements.line = {
                    tension: .4,
                    backgroundColor: g.defaultColor,
                    borderWidth: 3,
                    borderColor: g.defaultColor,
                    borderCapStyle: "butt",
                    borderDash: [],
                    borderDashOffset: 0,
                    borderJoinStyle: "miter",
                    capBezierPoints: !0,
                    fill: !0
                }, t.elements.Line = t.Element.extend({
                    draw: function() {
                        function t(t, e) {
                            var a = e._view;
                            !0 === e._view.steppedLine ? (o.lineTo(a.x, t._view.y), o.lineTo(a.x, a.y)) : 0 === e._view.tension ? o.lineTo(a.x, a.y) : o.bezierCurveTo(t._view.controlPointNextX, t._view.controlPointNextY, a.controlPointPreviousX, a.controlPointPreviousY, a.x, a.y);
                        }
                        var e = this._view, a = e.spanGaps, n = e.scaleZero, i = this._loop;
                        i || ("top" === e.fill ? n = e.scaleTop : "bottom" === e.fill && (n = e.scaleBottom));
                        var o = this._chart.ctx;
                        o.save();
                        var r, l, s, d, u = this._children.slice(), c = -1;
                        if (i && u.length && u.push(u[0]), u.length && e.fill) {
                            for (o.beginPath(), r = 0; r < u.length; ++r) l = u[r], s = f.previousItem(u, r), 
                            d = l._view, 0 === r ? (i ? o.moveTo(n.x, n.y) : o.moveTo(d.x, n), d.skip || (c = r, 
                            o.lineTo(d.x, d.y))) : (s = -1 === c ? s : u[c], d.skip ? a || c !== r - 1 || (i ? o.lineTo(n.x, n.y) : o.lineTo(s._view.x, n)) : (c !== r - 1 ? a && -1 !== c ? t(s, l) : (i || o.lineTo(d.x, n), 
                            o.lineTo(d.x, d.y)) : t(s, l), c = r));
                            i || -1 === c || o.lineTo(u[c]._view.x, n), o.setFillStyle(e.backgroundColor || g.defaultColor), 
                            o.closePath(), o.fill();
                        }
                        var h = g.elements.line;
                        for (o.setLineCap(e.borderCapStyle || h.borderCapStyle), o.setLineDash && o.setLineDash(e.borderDash || h.borderDash), 
                        o.lineDashOffset = e.borderDashOffset || h.borderDashOffset, o.setLineJoin(e.borderJoinStyle || h.borderJoinStyle), 
                        o.setLineWidth(e.borderWidth || h.borderWidth), o.setStrokeStyle(e.borderColor || g.defaultColor), 
                        o.beginPath(), c = -1, r = 0; r < u.length; ++r) l = u[r], s = f.previousItem(u, r), 
                        d = l._view, 0 === r ? d.skip || (o.moveTo(d.x, d.y), c = r) : (s = -1 === c ? s : u[c], 
                        d.skip || (c !== r - 1 && !a || -1 === c ? o.moveTo(d.x, d.y) : t(s, l), c = r));
                        o.stroke(), o.restore();
                    }
                });
            };
        }, {} ],
        33: [ function(t, e, a) {
            e.exports = function(r) {
                function t(t) {
                    var e = this._view;
                    return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hitRadius, 2);
                }
                var l = r.helpers, s = r.defaults.global, d = s.defaultColor;
                s.elements.point = {
                    radius: 3,
                    pointStyle: "circle",
                    backgroundColor: d,
                    borderWidth: 1,
                    borderColor: d,
                    hitRadius: 1,
                    hoverRadius: 4,
                    hoverBorderWidth: 1
                }, r.elements.Point = r.Element.extend({
                    inRange: function(t, e) {
                        var a = this._view;
                        return !!a && Math.pow(t - a.x, 2) + Math.pow(e - a.y, 2) < Math.pow(a.hitRadius + a.radius, 2);
                    },
                    inLabelRange: t,
                    inXRange: t,
                    inYRange: function(t) {
                        var e = this._view;
                        return !!e && Math.pow(t - e.y, 2) < Math.pow(e.radius + e.hitRadius, 2);
                    },
                    getCenterPoint: function() {
                        var t = this._view;
                        return {
                            x: t.x,
                            y: t.y
                        };
                    },
                    getArea: function() {
                        return Math.PI * Math.pow(this._view.radius, 2);
                    },
                    tooltipPosition: function() {
                        var t = this._view;
                        return {
                            x: t.x,
                            y: t.y,
                            padding: t.radius + t.borderWidth
                        };
                    },
                    draw: function() {
                        var t = this._view, e = this._chart.ctx, a = t.pointStyle, n = t.radius, i = t.x, o = t.y;
                        t.skip || (e.setStrokeStyle(t.borderColor || d), e.setLineWidth(l.getValueOrDefault(t.borderWidth, s.elements.point.borderWidth)), 
                        e.setFillStyle(t.backgroundColor || d), r.canvasHelpers.drawPoint(e, a, n, i, o));
                    }
                });
            };
        }, {} ],
        34: [ function(t, e, a) {
            e.exports = function(t) {
                function s(t) {
                    return void 0 !== t._view.width;
                }
                function i(t) {
                    var e, a, n, i, o = t._view;
                    if (s(t)) {
                        var r = o.width / 2;
                        e = o.x - r, a = o.x + r, n = Math.min(o.y, o.base), i = Math.max(o.y, o.base);
                    } else {
                        var l = o.height / 2;
                        e = Math.min(o.x, o.base), a = Math.max(o.x, o.base), n = o.y - l, i = o.y + l;
                    }
                    return {
                        left: e,
                        top: n,
                        right: a,
                        bottom: i
                    };
                }
                var e = t.defaults.global;
                e.elements.rectangle = {
                    backgroundColor: e.defaultColor,
                    borderWidth: 0,
                    borderColor: e.defaultColor,
                    borderSkipped: "bottom"
                }, t.elements.Rectangle = t.Element.extend({
                    draw: function() {
                        function t(t) {
                            return s[(d + t) % 4];
                        }
                        var e = this._chart.ctx, a = this._view, n = a.width / 2, i = a.x - n, o = a.x + n, r = a.base - (a.base - a.y), l = a.borderWidth / 2;
                        a.borderWidth && (i += l, o -= l, r += l), e.beginPath(), e.setFillStyle(a.backgroundColor), 
                        e.setStrokeStyle(a.borderColor), e.setLineWidth(a.borderWidth);
                        var s = [ [ i, a.base ], [ i, r ], [ o, r ], [ o, a.base ] ], d = [ "bottom", "left", "top", "right" ].indexOf(a.borderSkipped, 0);
                        -1 === d && (d = 0);
                        var u = t(0);
                        e.moveTo(u[0], u[1]);
                        for (var c = 1; c < 4; c++) u = t(c), e.lineTo(u[0], u[1]);
                        e.fill(), a.borderWidth && e.stroke();
                    },
                    height: function() {
                        var t = this._view;
                        return t.base - t.y;
                    },
                    inRange: function(t, e) {
                        var a = !1;
                        if (this._view) {
                            var n = i(this);
                            a = t >= n.left && t <= n.right && e >= n.top && e <= n.bottom;
                        }
                        return a;
                    },
                    inLabelRange: function(t, e) {
                        if (!this._view) return !1;
                        var a = i(this);
                        return s(this) ? t >= a.left && t <= a.right : e >= a.top && e <= a.bottom;
                    },
                    inXRange: function(t) {
                        var e = i(this);
                        return t >= e.left && t <= e.right;
                    },
                    inYRange: function(t) {
                        var e = i(this);
                        return t >= e.top && t <= e.bottom;
                    },
                    getCenterPoint: function() {
                        var t, e, a = this._view;
                        return e = s(this) ? (t = a.x, (a.y + a.base) / 2) : (t = (a.x + a.base) / 2, a.y), 
                        {
                            x: t,
                            y: e
                        };
                    },
                    getArea: function() {
                        var t = this._view;
                        return t.width * Math.abs(t.y - t.base);
                    },
                    tooltipPosition: function() {
                        var t = this._view;
                        return {
                            x: t.x,
                            y: t.y
                        };
                    }
                });
            };
        }, {} ],
        35: [ function(t, e, a) {
            function n(t) {
                if (t) {
                    var e = [ 0, 0, 0 ], a = 1, n = t.match(/^#([a-fA-F0-9]{3})$/);
                    if (n) {
                        n = n[1];
                        for (var i = 0; i < e.length; i++) e[i] = parseInt(n[i] + n[i], 16);
                    } else if (n = t.match(/^#([a-fA-F0-9]{6})$/)) {
                        n = n[1];
                        for (i = 0; i < e.length; i++) e[i] = parseInt(n.slice(2 * i, 2 * i + 2), 16);
                    } else if (n = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/)) {
                        for (i = 0; i < e.length; i++) e[i] = parseInt(n[i + 1]);
                        a = parseFloat(n[4]);
                    } else if (n = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/)) {
                        for (i = 0; i < e.length; i++) e[i] = Math.round(2.55 * parseFloat(n[i + 1]));
                        a = parseFloat(n[4]);
                    } else if (n = t.match(/(\w+)/)) {
                        if ("transparent" == n[1]) return [ 0, 0, 0, 0 ];
                        if (!(e = c[n[1]])) return;
                    }
                    for (i = 0; i < e.length; i++) e[i] = d(e[i], 0, 255);
                    return a = a || 0 == a ? d(a, 0, 1) : 1, e[3] = a, e;
                }
            }
            function i(t) {
                if (t) {
                    var e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
                    if (e) {
                        var a = parseFloat(e[4]);
                        return [ d(parseInt(e[1]), 0, 360), d(parseFloat(e[2]), 0, 100), d(parseFloat(e[3]), 0, 100), d(isNaN(a) ? 1 : a, 0, 1) ];
                    }
                }
            }
            function o(t) {
                if (t) {
                    var e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);
                    if (e) {
                        var a = parseFloat(e[4]);
                        return [ d(parseInt(e[1]), 0, 360), d(parseFloat(e[2]), 0, 100), d(parseFloat(e[3]), 0, 100), d(isNaN(a) ? 1 : a, 0, 1) ];
                    }
                }
            }
            function r(t, e) {
                return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")";
            }
            function l(t, e) {
                return "rgba(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%, " + (e || t[3] || 1) + ")";
            }
            function s(t, e) {
                return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")";
            }
            function d(t, e, a) {
                return Math.min(Math.max(e, t), a);
            }
            function u(t) {
                var e = t.toString(16).toUpperCase();
                return e.length < 2 ? "0" + e : e;
            }
            var c = t(38);
            e.exports = {
                getRgba: n,
                getHsla: i,
                getRgb: function(t) {
                    var e = n(t);
                    return e && e.slice(0, 3);
                },
                getHsl: function(t) {
                    var e = i(t);
                    return e && e.slice(0, 3);
                },
                getHwb: o,
                getAlpha: function(t) {
                    var e = n(t);
                    return e ? e[3] : (e = i(t)) ? e[3] : (e = o(t)) ? e[3] : void 0;
                },
                hexString: function(t) {
                    return "#" + u(t[0]) + u(t[1]) + u(t[2]);
                },
                rgbString: function(t, e) {
                    return e < 1 || t[3] && t[3] < 1 ? r(t, e) : "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
                },
                rgbaString: r,
                percentString: function(t, e) {
                    return e < 1 || t[3] && t[3] < 1 ? l(t, e) : "rgb(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%)";
                },
                percentaString: l,
                hslString: function(t, e) {
                    return e < 1 || t[3] && t[3] < 1 ? s(t, e) : "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)";
                },
                hslaString: s,
                hwbString: function(t, e) {
                    return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + (void 0 !== e && 1 !== e ? ", " + e : "") + ")";
                },
                keyword: function(t) {
                    return h[t.slice(0, 3)];
                }
            };
            var h = {};
            for (var f in c) h[c[f]] = f;
        }, {
            38: 38
        } ],
        36: [ function(t, e, a) {
            var u = t(37), n = t(35), r = function t(e) {
                if (e instanceof t) return e;
                if (!(this instanceof t)) return new t(e);
                var a;
                if (this.values = {
                    rgb: [ 0, 0, 0 ],
                    hsl: [ 0, 0, 0 ],
                    hsv: [ 0, 0, 0 ],
                    hwb: [ 0, 0, 0 ],
                    cmyk: [ 0, 0, 0, 0 ],
                    alpha: 1
                }, "string" == typeof e) if (a = n.getRgba(e)) this.setValues("rgb", a); else if (a = n.getHsla(e)) this.setValues("hsl", a); else {
                    if (!(a = n.getHwb(e))) throw new Error('Unable to parse color from string "' + e + '"');
                    this.setValues("hwb", a);
                } else if ("object" == (void 0 === e ? "undefined" : m(e))) if (void 0 !== (a = e).r || void 0 !== a.red) this.setValues("rgb", a); else if (void 0 !== a.l || void 0 !== a.lightness) this.setValues("hsl", a); else if (void 0 !== a.v || void 0 !== a.value) this.setValues("hsv", a); else if (void 0 !== a.w || void 0 !== a.whiteness) this.setValues("hwb", a); else {
                    if (void 0 === a.c && void 0 === a.cyan) throw new Error("Unable to parse color from object " + JSON.stringify(e));
                    this.setValues("cmyk", a);
                }
            };
            (r.prototype = {
                rgb: function() {
                    return this.setSpace("rgb", arguments);
                },
                hsl: function() {
                    return this.setSpace("hsl", arguments);
                },
                hsv: function() {
                    return this.setSpace("hsv", arguments);
                },
                hwb: function() {
                    return this.setSpace("hwb", arguments);
                },
                cmyk: function() {
                    return this.setSpace("cmyk", arguments);
                },
                rgbArray: function() {
                    return this.values.rgb;
                },
                hslArray: function() {
                    return this.values.hsl;
                },
                hsvArray: function() {
                    return this.values.hsv;
                },
                hwbArray: function() {
                    var t = this.values;
                    return 1 !== t.alpha ? t.hwb.concat([ t.alpha ]) : t.hwb;
                },
                cmykArray: function() {
                    return this.values.cmyk;
                },
                rgbaArray: function() {
                    var t = this.values;
                    return t.rgb.concat([ t.alpha ]);
                },
                hslaArray: function() {
                    var t = this.values;
                    return t.hsl.concat([ t.alpha ]);
                },
                alpha: function(t) {
                    return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this);
                },
                red: function(t) {
                    return this.setChannel("rgb", 0, t);
                },
                green: function(t) {
                    return this.setChannel("rgb", 1, t);
                },
                blue: function(t) {
                    return this.setChannel("rgb", 2, t);
                },
                hue: function(t) {
                    return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t);
                },
                saturation: function(t) {
                    return this.setChannel("hsl", 1, t);
                },
                lightness: function(t) {
                    return this.setChannel("hsl", 2, t);
                },
                saturationv: function(t) {
                    return this.setChannel("hsv", 1, t);
                },
                whiteness: function(t) {
                    return this.setChannel("hwb", 1, t);
                },
                blackness: function(t) {
                    return this.setChannel("hwb", 2, t);
                },
                value: function(t) {
                    return this.setChannel("hsv", 2, t);
                },
                cyan: function(t) {
                    return this.setChannel("cmyk", 0, t);
                },
                magenta: function(t) {
                    return this.setChannel("cmyk", 1, t);
                },
                yellow: function(t) {
                    return this.setChannel("cmyk", 2, t);
                },
                black: function(t) {
                    return this.setChannel("cmyk", 3, t);
                },
                hexString: function() {
                    return n.hexString(this.values.rgb);
                },
                rgbString: function() {
                    return n.rgbString(this.values.rgb, this.values.alpha);
                },
                rgbaString: function() {
                    return n.rgbaString(this.values.rgb, this.values.alpha);
                },
                percentString: function() {
                    return n.percentString(this.values.rgb, this.values.alpha);
                },
                hslString: function() {
                    return n.hslString(this.values.hsl, this.values.alpha);
                },
                hslaString: function() {
                    return n.hslaString(this.values.hsl, this.values.alpha);
                },
                hwbString: function() {
                    return n.hwbString(this.values.hwb, this.values.alpha);
                },
                keyword: function() {
                    return n.keyword(this.values.rgb, this.values.alpha);
                },
                rgbNumber: function() {
                    var t = this.values.rgb;
                    return t[0] << 16 | t[1] << 8 | t[2];
                },
                luminosity: function() {
                    for (var t = this.values.rgb, e = [], a = 0; a < t.length; a++) {
                        var n = t[a] / 255;
                        e[a] = n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4);
                    }
                    return .2126 * e[0] + .7152 * e[1] + .0722 * e[2];
                },
                contrast: function(t) {
                    var e = this.luminosity(), a = t.luminosity();
                    return a < e ? (e + .05) / (a + .05) : (a + .05) / (e + .05);
                },
                level: function(t) {
                    var e = this.contrast(t);
                    return 7.1 <= e ? "AAA" : 4.5 <= e ? "AA" : "";
                },
                dark: function() {
                    var t = this.values.rgb;
                    return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128;
                },
                light: function() {
                    return !this.dark();
                },
                negate: function() {
                    for (var t = [], e = 0; e < 3; e++) t[e] = 255 - this.values.rgb[e];
                    return this.setValues("rgb", t), this;
                },
                lighten: function(t) {
                    var e = this.values.hsl;
                    return e[2] += e[2] * t, this.setValues("hsl", e), this;
                },
                darken: function(t) {
                    var e = this.values.hsl;
                    return e[2] -= e[2] * t, this.setValues("hsl", e), this;
                },
                saturate: function(t) {
                    var e = this.values.hsl;
                    return e[1] += e[1] * t, this.setValues("hsl", e), this;
                },
                desaturate: function(t) {
                    var e = this.values.hsl;
                    return e[1] -= e[1] * t, this.setValues("hsl", e), this;
                },
                whiten: function(t) {
                    var e = this.values.hwb;
                    return e[1] += e[1] * t, this.setValues("hwb", e), this;
                },
                blacken: function(t) {
                    var e = this.values.hwb;
                    return e[2] += e[2] * t, this.setValues("hwb", e), this;
                },
                greyscale: function() {
                    var t = this.values.rgb, e = .3 * t[0] + .59 * t[1] + .11 * t[2];
                    return this.setValues("rgb", [ e, e, e ]), this;
                },
                clearer: function(t) {
                    var e = this.values.alpha;
                    return this.setValues("alpha", e - e * t), this;
                },
                opaquer: function(t) {
                    var e = this.values.alpha;
                    return this.setValues("alpha", e + e * t), this;
                },
                rotate: function(t) {
                    var e = this.values.hsl, a = (e[0] + t) % 360;
                    return e[0] = a < 0 ? 360 + a : a, this.setValues("hsl", e), this;
                },
                mix: function(t, e) {
                    var a = this, n = t, i = void 0 === e ? .5 : e, o = 2 * i - 1, r = a.alpha() - n.alpha(), l = ((o * r == -1 ? o : (o + r) / (1 + o * r)) + 1) / 2, s = 1 - l;
                    return this.rgb(l * a.red() + s * n.red(), l * a.green() + s * n.green(), l * a.blue() + s * n.blue()).alpha(a.alpha() * i + n.alpha() * (1 - i));
                },
                toJSON: function() {
                    return this.rgb();
                },
                clone: function() {
                    var t, e, a = new r(), n = this.values, i = a.values;
                    for (var o in n) n.hasOwnProperty(o) && (t = n[o], "[object Array]" === (e = {}.toString.call(t)) ? i[o] = t.slice(0) : "[object Number]" === e ? i[o] = t : console.error("unexpected color value:", t));
                    return a;
                }
            }).spaces = {
                rgb: [ "red", "green", "blue" ],
                hsl: [ "hue", "saturation", "lightness" ],
                hsv: [ "hue", "saturation", "value" ],
                hwb: [ "hue", "whiteness", "blackness" ],
                cmyk: [ "cyan", "magenta", "yellow", "black" ]
            }, r.prototype.maxes = {
                rgb: [ 255, 255, 255 ],
                hsl: [ 360, 100, 100 ],
                hsv: [ 360, 100, 100 ],
                hwb: [ 360, 100, 100 ],
                cmyk: [ 100, 100, 100, 100 ]
            }, r.prototype.getValues = function(t) {
                for (var e = this.values, a = {}, n = 0; n < t.length; n++) a[t.charAt(n)] = e[t][n];
                return 1 !== e.alpha && (a.a = e.alpha), a;
            }, r.prototype.setValues = function(t, e) {
                var a, n, i = this.values, o = this.spaces, r = this.maxes, l = 1;
                if ("alpha" === t) l = e; else if (e.length) i[t] = e.slice(0, t.length), l = e[t.length]; else if (void 0 !== e[t.charAt(0)]) {
                    for (a = 0; a < t.length; a++) i[t][a] = e[t.charAt(a)];
                    l = e.a;
                } else if (void 0 !== e[o[t][0]]) {
                    var s = o[t];
                    for (a = 0; a < t.length; a++) i[t][a] = e[s[a]];
                    l = e.alpha;
                }
                if (i.alpha = Math.max(0, Math.min(1, void 0 === l ? i.alpha : l)), "alpha" === t) return !1;
                for (a = 0; a < t.length; a++) n = Math.max(0, Math.min(r[t][a], i[t][a])), i[t][a] = Math.round(n);
                for (var d in o) d !== t && (i[d] = u[t][d](i[t]));
                return !0;
            }, r.prototype.setSpace = function(t, e) {
                var a = e[0];
                return void 0 === a ? this.getValues(t) : ("number" == typeof a && (a = Array.prototype.slice.call(e)), 
                this.setValues(t, a), this);
            }, r.prototype.setChannel = function(t, e, a) {
                var n = this.values[t];
                return void 0 === a ? n[e] : (a === n[e] || (n[e] = a, this.setValues(t, n)), this);
            }, "undefined" != typeof window && (window.Color = r), e.exports = r;
        }, {
            35: 35,
            37: 37
        } ],
        37: [ function(t, e, a) {
            var i = t(39), o = function() {
                return new d();
            };
            for (var n in i) {
                o[n + "Raw"] = function(e) {
                    return function(t) {
                        return "number" == typeof t && (t = Array.prototype.slice.call(arguments)), i[e](t);
                    };
                }(n);
                var r = /(\w+)2(\w+)/.exec(n), l = r[1], s = r[2];
                (o[l] = o[l] || {})[s] = o[n] = function(n) {
                    return function(t) {
                        "number" == typeof t && (t = Array.prototype.slice.call(arguments));
                        var e = i[n](t);
                        if ("string" == typeof e || void 0 === e) return e;
                        for (var a = 0; a < e.length; a++) e[a] = Math.round(e[a]);
                        return e;
                    };
                }(n);
            }
            var d = function() {
                this.convs = {};
            };
            d.prototype.routeSpace = function(t, e) {
                var a = e[0];
                return void 0 === a ? this.getValues(t) : ("number" == typeof a && (a = Array.prototype.slice.call(e)), 
                this.setValues(t, a));
            }, d.prototype.setValues = function(t, e) {
                return this.space = t, this.convs = {}, this.convs[t] = e, this;
            }, d.prototype.getValues = function(t) {
                var e = this.convs[t];
                if (!e) {
                    var a = this.space, n = this.convs[a];
                    e = o[a][t](n), this.convs[t] = e;
                }
                return e;
            }, [ "rgb", "hsl", "hsv", "cmyk", "keyword" ].forEach(function(e) {
                d.prototype[e] = function(t) {
                    return this.routeSpace(e, arguments);
                };
            }), e.exports = o;
        }, {
            39: 39
        } ],
        38: [ function(t, e, a) {
            e.exports = {
                aliceblue: [ 240, 248, 255 ],
                antiquewhite: [ 250, 235, 215 ],
                aqua: [ 0, 255, 255 ],
                aquamarine: [ 127, 255, 212 ],
                azure: [ 240, 255, 255 ],
                beige: [ 245, 245, 220 ],
                bisque: [ 255, 228, 196 ],
                black: [ 0, 0, 0 ],
                blanchedalmond: [ 255, 235, 205 ],
                blue: [ 0, 0, 255 ],
                blueviolet: [ 138, 43, 226 ],
                brown: [ 165, 42, 42 ],
                burlywood: [ 222, 184, 135 ],
                cadetblue: [ 95, 158, 160 ],
                chartreuse: [ 127, 255, 0 ],
                chocolate: [ 210, 105, 30 ],
                coral: [ 255, 127, 80 ],
                cornflowerblue: [ 100, 149, 237 ],
                cornsilk: [ 255, 248, 220 ],
                crimson: [ 220, 20, 60 ],
                cyan: [ 0, 255, 255 ],
                darkblue: [ 0, 0, 139 ],
                darkcyan: [ 0, 139, 139 ],
                darkgoldenrod: [ 184, 134, 11 ],
                darkgray: [ 169, 169, 169 ],
                darkgreen: [ 0, 100, 0 ],
                darkgrey: [ 169, 169, 169 ],
                darkkhaki: [ 189, 183, 107 ],
                darkmagenta: [ 139, 0, 139 ],
                darkolivegreen: [ 85, 107, 47 ],
                darkorange: [ 255, 140, 0 ],
                darkorchid: [ 153, 50, 204 ],
                darkred: [ 139, 0, 0 ],
                darksalmon: [ 233, 150, 122 ],
                darkseagreen: [ 143, 188, 143 ],
                darkslateblue: [ 72, 61, 139 ],
                darkslategray: [ 47, 79, 79 ],
                darkslategrey: [ 47, 79, 79 ],
                darkturquoise: [ 0, 206, 209 ],
                darkviolet: [ 148, 0, 211 ],
                deeppink: [ 255, 20, 147 ],
                deepskyblue: [ 0, 191, 255 ],
                dimgray: [ 105, 105, 105 ],
                dimgrey: [ 105, 105, 105 ],
                dodgerblue: [ 30, 144, 255 ],
                firebrick: [ 178, 34, 34 ],
                floralwhite: [ 255, 250, 240 ],
                forestgreen: [ 34, 139, 34 ],
                fuchsia: [ 255, 0, 255 ],
                gainsboro: [ 220, 220, 220 ],
                ghostwhite: [ 248, 248, 255 ],
                gold: [ 255, 215, 0 ],
                goldenrod: [ 218, 165, 32 ],
                gray: [ 128, 128, 128 ],
                green: [ 0, 128, 0 ],
                greenyellow: [ 173, 255, 47 ],
                grey: [ 128, 128, 128 ],
                honeydew: [ 240, 255, 240 ],
                hotpink: [ 255, 105, 180 ],
                indianred: [ 205, 92, 92 ],
                indigo: [ 75, 0, 130 ],
                ivory: [ 255, 255, 240 ],
                khaki: [ 240, 230, 140 ],
                lavender: [ 230, 230, 250 ],
                lavenderblush: [ 255, 240, 245 ],
                lawngreen: [ 124, 252, 0 ],
                lemonchiffon: [ 255, 250, 205 ],
                lightblue: [ 173, 216, 230 ],
                lightcoral: [ 240, 128, 128 ],
                lightcyan: [ 224, 255, 255 ],
                lightgoldenrodyellow: [ 250, 250, 210 ],
                lightgray: [ 211, 211, 211 ],
                lightgreen: [ 144, 238, 144 ],
                lightgrey: [ 211, 211, 211 ],
                lightpink: [ 255, 182, 193 ],
                lightsalmon: [ 255, 160, 122 ],
                lightseagreen: [ 32, 178, 170 ],
                lightskyblue: [ 135, 206, 250 ],
                lightslategray: [ 119, 136, 153 ],
                lightslategrey: [ 119, 136, 153 ],
                lightsteelblue: [ 176, 196, 222 ],
                lightyellow: [ 255, 255, 224 ],
                lime: [ 0, 255, 0 ],
                limegreen: [ 50, 205, 50 ],
                linen: [ 250, 240, 230 ],
                magenta: [ 255, 0, 255 ],
                maroon: [ 128, 0, 0 ],
                mediumaquamarine: [ 102, 205, 170 ],
                mediumblue: [ 0, 0, 205 ],
                mediumorchid: [ 186, 85, 211 ],
                mediumpurple: [ 147, 112, 219 ],
                mediumseagreen: [ 60, 179, 113 ],
                mediumslateblue: [ 123, 104, 238 ],
                mediumspringgreen: [ 0, 250, 154 ],
                mediumturquoise: [ 72, 209, 204 ],
                mediumvioletred: [ 199, 21, 133 ],
                midnightblue: [ 25, 25, 112 ],
                mintcream: [ 245, 255, 250 ],
                mistyrose: [ 255, 228, 225 ],
                moccasin: [ 255, 228, 181 ],
                navajowhite: [ 255, 222, 173 ],
                navy: [ 0, 0, 128 ],
                oldlace: [ 253, 245, 230 ],
                olive: [ 128, 128, 0 ],
                olivedrab: [ 107, 142, 35 ],
                orange: [ 255, 165, 0 ],
                orangered: [ 255, 69, 0 ],
                orchid: [ 218, 112, 214 ],
                palegoldenrod: [ 238, 232, 170 ],
                palegreen: [ 152, 251, 152 ],
                paleturquoise: [ 175, 238, 238 ],
                palevioletred: [ 219, 112, 147 ],
                papayawhip: [ 255, 239, 213 ],
                peachpuff: [ 255, 218, 185 ],
                peru: [ 205, 133, 63 ],
                pink: [ 255, 192, 203 ],
                plum: [ 221, 160, 221 ],
                powderblue: [ 176, 224, 230 ],
                purple: [ 128, 0, 128 ],
                rebeccapurple: [ 102, 51, 153 ],
                red: [ 255, 0, 0 ],
                rosybrown: [ 188, 143, 143 ],
                royalblue: [ 65, 105, 225 ],
                saddlebrown: [ 139, 69, 19 ],
                salmon: [ 250, 128, 114 ],
                sandybrown: [ 244, 164, 96 ],
                seagreen: [ 46, 139, 87 ],
                seashell: [ 255, 245, 238 ],
                sienna: [ 160, 82, 45 ],
                silver: [ 192, 192, 192 ],
                skyblue: [ 135, 206, 235 ],
                slateblue: [ 106, 90, 205 ],
                slategray: [ 112, 128, 144 ],
                slategrey: [ 112, 128, 144 ],
                snow: [ 255, 250, 250 ],
                springgreen: [ 0, 255, 127 ],
                steelblue: [ 70, 130, 180 ],
                tan: [ 210, 180, 140 ],
                teal: [ 0, 128, 128 ],
                thistle: [ 216, 191, 216 ],
                tomato: [ 255, 99, 71 ],
                turquoise: [ 64, 224, 208 ],
                violet: [ 238, 130, 238 ],
                wheat: [ 245, 222, 179 ],
                white: [ 255, 255, 255 ],
                whitesmoke: [ 245, 245, 245 ],
                yellow: [ 255, 255, 0 ],
                yellowgreen: [ 154, 205, 50 ]
            };
        }, {} ],
        39: [ function(t, e, a) {
            function i(t) {
                var e, a, n = t[0] / 255, i = t[1] / 255, o = t[2] / 255, r = Math.min(n, i, o), l = Math.max(n, i, o), s = l - r;
                return l == r ? e = 0 : n == l ? e = (i - o) / s : i == l ? e = 2 + (o - n) / s : o == l && (e = 4 + (n - i) / s), 
                (e = Math.min(60 * e, 360)) < 0 && (e += 360), a = (r + l) / 2, [ e, 100 * (l == r ? 0 : a <= .5 ? s / (l + r) : s / (2 - l - r)), 100 * a ];
            }
            function n(t) {
                var e, a, n = t[0], i = t[1], o = t[2], r = Math.min(n, i, o), l = Math.max(n, i, o), s = l - r;
                return a = 0 == l ? 0 : s / l * 1e3 / 10, l == r ? e = 0 : n == l ? e = (i - o) / s : i == l ? e = 2 + (o - n) / s : o == l && (e = 4 + (n - i) / s), 
                (e = Math.min(60 * e, 360)) < 0 && (e += 360), [ e, a, l / 255 * 1e3 / 10 ];
            }
            function o(t) {
                var e = t[0], a = t[1], n = t[2];
                return [ i(t)[0], 100 * (1 / 255 * Math.min(e, Math.min(a, n))), 100 * (n = 1 - 1 / 255 * Math.max(e, Math.max(a, n))) ];
            }
            function l(t) {
                var e, a = t[0] / 255, n = t[1] / 255, i = t[2] / 255;
                return [ 100 * ((1 - a - (e = Math.min(1 - a, 1 - n, 1 - i))) / (1 - e) || 0), 100 * ((1 - n - e) / (1 - e) || 0), 100 * ((1 - i - e) / (1 - e) || 0), 100 * e ];
            }
            function s(t) {
                return M[JSON.stringify(t)];
            }
            function d(t) {
                var e = t[0] / 255, a = t[1] / 255, n = t[2] / 255;
                return [ 100 * (.4124 * (e = .04045 < e ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92) + .3576 * (a = .04045 < a ? Math.pow((a + .055) / 1.055, 2.4) : a / 12.92) + .1805 * (n = .04045 < n ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92)), 100 * (.2126 * e + .7152 * a + .0722 * n), 100 * (.0193 * e + .1192 * a + .9505 * n) ];
            }
            function u(t) {
                var e = d(t), a = e[0], n = e[1], i = e[2];
                return n /= 100, i /= 108.883, a = .008856 < (a /= 95.047) ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116, 
                [ 116 * (n = .008856 < n ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (a - n), 200 * (n - (i = .008856 < i ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116)) ];
            }
            function c(t) {
                var e, a, n, i, o, r = t[0] / 360, l = t[1] / 100, s = t[2] / 100;
                if (0 == l) return [ o = 255 * s, o, o ];
                e = 2 * s - (a = s < .5 ? s * (1 + l) : s + l - s * l), i = [ 0, 0, 0 ];
                for (var d = 0; d < 3; d++) (n = r + 1 / 3 * -(d - 1)) < 0 && n++, 1 < n && n--, 
                o = 6 * n < 1 ? e + 6 * (a - e) * n : 2 * n < 1 ? a : 3 * n < 2 ? e + (a - e) * (2 / 3 - n) * 6 : e, 
                i[d] = 255 * o;
                return i;
            }
            function h(t) {
                var e = t[0] / 60, a = t[1] / 100, n = t[2] / 100, i = Math.floor(e) % 6, o = e - Math.floor(e), r = 255 * n * (1 - a), l = 255 * n * (1 - a * o), s = 255 * n * (1 - a * (1 - o));
                n *= 255;
                switch (i) {
                  case 0:
                    return [ n, s, r ];

                  case 1:
                    return [ l, n, r ];

                  case 2:
                    return [ r, n, s ];

                  case 3:
                    return [ r, l, n ];

                  case 4:
                    return [ s, r, n ];

                  case 5:
                    return [ n, r, l ];
                }
            }
            function f(t) {
                var e, a, n, i, o = t[0] / 360, l = t[1] / 100, s = t[2] / 100, d = l + s;
                switch (1 < d && (l /= d, s /= d), n = 6 * o - (e = Math.floor(6 * o)), 0 != (1 & e) && (n = 1 - n), 
                i = l + n * ((a = 1 - s) - l), e) {
                  default:
                  case 6:
                  case 0:
                    r = a, g = i, b = l;
                    break;

                  case 1:
                    r = i, g = a, b = l;
                    break;

                  case 2:
                    r = l, g = a, b = i;
                    break;

                  case 3:
                    r = l, g = i, b = a;
                    break;

                  case 4:
                    r = i, g = l, b = a;
                    break;

                  case 5:
                    r = a, g = l, b = i;
                }
                return [ 255 * r, 255 * g, 255 * b ];
            }
            function p(t) {
                var e = t[0] / 100, a = t[1] / 100, n = t[2] / 100, i = t[3] / 100;
                return [ 255 * (1 - Math.min(1, e * (1 - i) + i)), 255 * (1 - Math.min(1, a * (1 - i) + i)), 255 * (1 - Math.min(1, n * (1 - i) + i)) ];
            }
            function m(t) {
                var e, a, n, i = t[0] / 100, o = t[1] / 100, r = t[2] / 100;
                return a = -.9689 * i + 1.8758 * o + .0415 * r, n = .0557 * i + -.204 * o + 1.057 * r, 
                e = .0031308 < (e = 3.2406 * i + -1.5372 * o + -.4986 * r) ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e *= 12.92, 
                a = .0031308 < a ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : a *= 12.92, n = .0031308 < n ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : n *= 12.92, 
                [ 255 * (e = Math.min(Math.max(0, e), 1)), 255 * (a = Math.min(Math.max(0, a), 1)), 255 * (n = Math.min(Math.max(0, n), 1)) ];
            }
            function v(t) {
                var e = t[0], a = t[1], n = t[2];
                return a /= 100, n /= 108.883, e = .008856 < (e /= 95.047) ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, 
                [ 116 * (a = .008856 < a ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116) - 16, 500 * (e - a), 200 * (a - (n = .008856 < n ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116)) ];
            }
            function x(t) {
                var e, a, n, i, o = t[0], r = t[1], l = t[2];
                return i = o <= 8 ? (a = 100 * o / 903.3) / 100 * 7.787 + 16 / 116 : (a = 100 * Math.pow((o + 16) / 116, 3), 
                Math.pow(a / 100, 1 / 3)), [ e = e / 95.047 <= .008856 ? e = 95.047 * (r / 500 + i - 16 / 116) / 7.787 : 95.047 * Math.pow(r / 500 + i, 3), a, n = n / 108.883 <= .008859 ? n = 108.883 * (i - l / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(i - l / 200, 3) ];
            }
            function y(t) {
                var e, a = t[0], n = t[1], i = t[2];
                return (e = 360 * Math.atan2(i, n) / 2 / Math.PI) < 0 && (e += 360), [ a, Math.sqrt(n * n + i * i), e ];
            }
            function k(t) {
                return m(x(t));
            }
            function S(t) {
                var e, a = t[0], n = t[1];
                return e = t[2] / 360 * 2 * Math.PI, [ a, n * Math.cos(e), n * Math.sin(e) ];
            }
            function C(t) {
                return w[t];
            }
            e.exports = {
                rgb2hsl: i,
                rgb2hsv: n,
                rgb2hwb: o,
                rgb2cmyk: l,
                rgb2keyword: s,
                rgb2xyz: d,
                rgb2lab: u,
                rgb2lch: function(t) {
                    return y(u(t));
                },
                hsl2rgb: c,
                hsl2hsv: function(t) {
                    var e = t[0], a = t[1] / 100, n = t[2] / 100;
                    return 0 === n ? [ 0, 0, 0 ] : [ e, 2 * (a *= (n *= 2) <= 1 ? n : 2 - n) / (n + a) * 100, (n + a) / 2 * 100 ];
                },
                hsl2hwb: function(t) {
                    return o(c(t));
                },
                hsl2cmyk: function(t) {
                    return l(c(t));
                },
                hsl2keyword: function(t) {
                    return s(c(t));
                },
                hsv2rgb: h,
                hsv2hsl: function(t) {
                    var e, a, n = t[0], i = t[1] / 100, o = t[2] / 100;
                    return e = i * o, [ n, 100 * (e = (e /= (a = (2 - i) * o) <= 1 ? a : 2 - a) || 0), 100 * (a /= 2) ];
                },
                hsv2hwb: function(t) {
                    return o(h(t));
                },
                hsv2cmyk: function(t) {
                    return l(h(t));
                },
                hsv2keyword: function(t) {
                    return s(h(t));
                },
                hwb2rgb: f,
                hwb2hsl: function(t) {
                    return i(f(t));
                },
                hwb2hsv: function(t) {
                    return n(f(t));
                },
                hwb2cmyk: function(t) {
                    return l(f(t));
                },
                hwb2keyword: function(t) {
                    return s(f(t));
                },
                cmyk2rgb: p,
                cmyk2hsl: function(t) {
                    return i(p(t));
                },
                cmyk2hsv: function(t) {
                    return n(p(t));
                },
                cmyk2hwb: function(t) {
                    return o(p(t));
                },
                cmyk2keyword: function(t) {
                    return s(p(t));
                },
                keyword2rgb: C,
                keyword2hsl: function(t) {
                    return i(C(t));
                },
                keyword2hsv: function(t) {
                    return n(C(t));
                },
                keyword2hwb: function(t) {
                    return o(C(t));
                },
                keyword2cmyk: function(t) {
                    return l(C(t));
                },
                keyword2lab: function(t) {
                    return u(C(t));
                },
                keyword2xyz: function(t) {
                    return d(C(t));
                },
                xyz2rgb: m,
                xyz2lab: v,
                xyz2lch: function(t) {
                    return y(v(t));
                },
                lab2xyz: x,
                lab2rgb: k,
                lab2lch: y,
                lch2lab: S,
                lch2xyz: function(t) {
                    return x(S(t));
                },
                lch2rgb: function(t) {
                    return k(S(t));
                }
            };
            var w = {
                aliceblue: [ 240, 248, 255 ],
                antiquewhite: [ 250, 235, 215 ],
                aqua: [ 0, 255, 255 ],
                aquamarine: [ 127, 255, 212 ],
                azure: [ 240, 255, 255 ],
                beige: [ 245, 245, 220 ],
                bisque: [ 255, 228, 196 ],
                black: [ 0, 0, 0 ],
                blanchedalmond: [ 255, 235, 205 ],
                blue: [ 0, 0, 255 ],
                blueviolet: [ 138, 43, 226 ],
                brown: [ 165, 42, 42 ],
                burlywood: [ 222, 184, 135 ],
                cadetblue: [ 95, 158, 160 ],
                chartreuse: [ 127, 255, 0 ],
                chocolate: [ 210, 105, 30 ],
                coral: [ 255, 127, 80 ],
                cornflowerblue: [ 100, 149, 237 ],
                cornsilk: [ 255, 248, 220 ],
                crimson: [ 220, 20, 60 ],
                cyan: [ 0, 255, 255 ],
                darkblue: [ 0, 0, 139 ],
                darkcyan: [ 0, 139, 139 ],
                darkgoldenrod: [ 184, 134, 11 ],
                darkgray: [ 169, 169, 169 ],
                darkgreen: [ 0, 100, 0 ],
                darkgrey: [ 169, 169, 169 ],
                darkkhaki: [ 189, 183, 107 ],
                darkmagenta: [ 139, 0, 139 ],
                darkolivegreen: [ 85, 107, 47 ],
                darkorange: [ 255, 140, 0 ],
                darkorchid: [ 153, 50, 204 ],
                darkred: [ 139, 0, 0 ],
                darksalmon: [ 233, 150, 122 ],
                darkseagreen: [ 143, 188, 143 ],
                darkslateblue: [ 72, 61, 139 ],
                darkslategray: [ 47, 79, 79 ],
                darkslategrey: [ 47, 79, 79 ],
                darkturquoise: [ 0, 206, 209 ],
                darkviolet: [ 148, 0, 211 ],
                deeppink: [ 255, 20, 147 ],
                deepskyblue: [ 0, 191, 255 ],
                dimgray: [ 105, 105, 105 ],
                dimgrey: [ 105, 105, 105 ],
                dodgerblue: [ 30, 144, 255 ],
                firebrick: [ 178, 34, 34 ],
                floralwhite: [ 255, 250, 240 ],
                forestgreen: [ 34, 139, 34 ],
                fuchsia: [ 255, 0, 255 ],
                gainsboro: [ 220, 220, 220 ],
                ghostwhite: [ 248, 248, 255 ],
                gold: [ 255, 215, 0 ],
                goldenrod: [ 218, 165, 32 ],
                gray: [ 128, 128, 128 ],
                green: [ 0, 128, 0 ],
                greenyellow: [ 173, 255, 47 ],
                grey: [ 128, 128, 128 ],
                honeydew: [ 240, 255, 240 ],
                hotpink: [ 255, 105, 180 ],
                indianred: [ 205, 92, 92 ],
                indigo: [ 75, 0, 130 ],
                ivory: [ 255, 255, 240 ],
                khaki: [ 240, 230, 140 ],
                lavender: [ 230, 230, 250 ],
                lavenderblush: [ 255, 240, 245 ],
                lawngreen: [ 124, 252, 0 ],
                lemonchiffon: [ 255, 250, 205 ],
                lightblue: [ 173, 216, 230 ],
                lightcoral: [ 240, 128, 128 ],
                lightcyan: [ 224, 255, 255 ],
                lightgoldenrodyellow: [ 250, 250, 210 ],
                lightgray: [ 211, 211, 211 ],
                lightgreen: [ 144, 238, 144 ],
                lightgrey: [ 211, 211, 211 ],
                lightpink: [ 255, 182, 193 ],
                lightsalmon: [ 255, 160, 122 ],
                lightseagreen: [ 32, 178, 170 ],
                lightskyblue: [ 135, 206, 250 ],
                lightslategray: [ 119, 136, 153 ],
                lightslategrey: [ 119, 136, 153 ],
                lightsteelblue: [ 176, 196, 222 ],
                lightyellow: [ 255, 255, 224 ],
                lime: [ 0, 255, 0 ],
                limegreen: [ 50, 205, 50 ],
                linen: [ 250, 240, 230 ],
                magenta: [ 255, 0, 255 ],
                maroon: [ 128, 0, 0 ],
                mediumaquamarine: [ 102, 205, 170 ],
                mediumblue: [ 0, 0, 205 ],
                mediumorchid: [ 186, 85, 211 ],
                mediumpurple: [ 147, 112, 219 ],
                mediumseagreen: [ 60, 179, 113 ],
                mediumslateblue: [ 123, 104, 238 ],
                mediumspringgreen: [ 0, 250, 154 ],
                mediumturquoise: [ 72, 209, 204 ],
                mediumvioletred: [ 199, 21, 133 ],
                midnightblue: [ 25, 25, 112 ],
                mintcream: [ 245, 255, 250 ],
                mistyrose: [ 255, 228, 225 ],
                moccasin: [ 255, 228, 181 ],
                navajowhite: [ 255, 222, 173 ],
                navy: [ 0, 0, 128 ],
                oldlace: [ 253, 245, 230 ],
                olive: [ 128, 128, 0 ],
                olivedrab: [ 107, 142, 35 ],
                orange: [ 255, 165, 0 ],
                orangered: [ 255, 69, 0 ],
                orchid: [ 218, 112, 214 ],
                palegoldenrod: [ 238, 232, 170 ],
                palegreen: [ 152, 251, 152 ],
                paleturquoise: [ 175, 238, 238 ],
                palevioletred: [ 219, 112, 147 ],
                papayawhip: [ 255, 239, 213 ],
                peachpuff: [ 255, 218, 185 ],
                peru: [ 205, 133, 63 ],
                pink: [ 255, 192, 203 ],
                plum: [ 221, 160, 221 ],
                powderblue: [ 176, 224, 230 ],
                purple: [ 128, 0, 128 ],
                rebeccapurple: [ 102, 51, 153 ],
                red: [ 255, 0, 0 ],
                rosybrown: [ 188, 143, 143 ],
                royalblue: [ 65, 105, 225 ],
                saddlebrown: [ 139, 69, 19 ],
                salmon: [ 250, 128, 114 ],
                sandybrown: [ 244, 164, 96 ],
                seagreen: [ 46, 139, 87 ],
                seashell: [ 255, 245, 238 ],
                sienna: [ 160, 82, 45 ],
                silver: [ 192, 192, 192 ],
                skyblue: [ 135, 206, 235 ],
                slateblue: [ 106, 90, 205 ],
                slategray: [ 112, 128, 144 ],
                slategrey: [ 112, 128, 144 ],
                snow: [ 255, 250, 250 ],
                springgreen: [ 0, 255, 127 ],
                steelblue: [ 70, 130, 180 ],
                tan: [ 210, 180, 140 ],
                teal: [ 0, 128, 128 ],
                thistle: [ 216, 191, 216 ],
                tomato: [ 255, 99, 71 ],
                turquoise: [ 64, 224, 208 ],
                violet: [ 238, 130, 238 ],
                wheat: [ 245, 222, 179 ],
                white: [ 255, 255, 255 ],
                whitesmoke: [ 245, 245, 245 ],
                yellow: [ 255, 255, 0 ],
                yellowgreen: [ 154, 205, 50 ]
            }, M = {};
            for (var D in w) M[JSON.stringify(w[D])] = D;
        }, {} ],
        40: [ function(t, e, a) {
            e.exports = function(t) {
                var n = t.helpers, e = t.Scale.extend({
                    getLabels: function() {
                        var t = this.chart.data;
                        return (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels;
                    },
                    determineDataLimits: function() {
                        var t, e = this, a = e.getLabels();
                        e.minIndex = 0, e.maxIndex = a.length - 1, void 0 !== e.options.ticks.min && (t = n.indexOf(a, e.options.ticks.min), 
                        e.minIndex = -1 !== t ? t : e.minIndex), void 0 !== e.options.ticks.max && (t = n.indexOf(a, e.options.ticks.max), 
                        e.maxIndex = -1 !== t ? t : e.maxIndex), e.min = a[e.minIndex], e.max = a[e.maxIndex];
                    },
                    buildTicks: function() {
                        var t = this, e = t.getLabels();
                        t.ticks = 0 === t.minIndex && t.maxIndex === e.length - 1 ? e : e.slice(t.minIndex, t.maxIndex + 1);
                    },
                    getLabelForIndex: function(t, e) {
                        var a = this.chart.data, n = this.isHorizontal();
                        return a.xLabels && n || a.yLabels && !n ? this.getRightValue(a.datasets[e].data[t]) : this.ticks[t];
                    },
                    getPixelForValue: function(t, e, a, n) {
                        var i = this, o = Math.max(i.maxIndex + 1 - i.minIndex - (i.options.gridLines.offsetGridLines ? 0 : 1), 1);
                        if (void 0 !== t && isNaN(e)) {
                            var r = i.getLabels().indexOf(t);
                            e = -1 !== r ? r : e;
                        }
                        if (i.isHorizontal()) {
                            var l = (i.width - (i.paddingLeft + i.paddingRight)) / o, s = l * (e - i.minIndex) + i.paddingLeft;
                            return (i.options.gridLines.offsetGridLines && n || i.maxIndex === i.minIndex && n) && (s += l / 2), 
                            i.left + Math.round(s);
                        }
                        var d = (i.height - (i.paddingTop + i.paddingBottom)) / o, u = d * (e - i.minIndex) + i.paddingTop;
                        return i.options.gridLines.offsetGridLines && n && (u += d / 2), i.top + Math.round(u);
                    },
                    getPixelForTick: function(t, e) {
                        return this.getPixelForValue(this.ticks[t], t + this.minIndex, null, e);
                    },
                    getValueForPixel: function(t) {
                        var e = this, a = Math.max(e.ticks.length - (e.options.gridLines.offsetGridLines ? 0 : 1), 1), n = e.isHorizontal(), i = (n ? e.width - (e.paddingLeft + e.paddingRight) : e.height - (e.paddingTop + e.paddingBottom)) / a;
                        return t -= n ? e.left : e.top, e.options.gridLines.offsetGridLines && (t -= i / 2), 
                        (t -= n ? e.paddingLeft : e.paddingTop) <= 0 ? 0 : Math.round(t / i);
                    },
                    getBasePixel: function() {
                        return this.bottom;
                    }
                });
                t.scaleService.registerScaleType("category", e, {
                    position: "bottom"
                });
            };
        }, {} ],
        41: [ function(t, e, a) {
            e.exports = function(n) {
                var u = n.helpers, t = {
                    position: "left",
                    ticks: {
                        callback: n.Ticks.formatters.linear
                    }
                }, e = n.LinearScaleBase.extend({
                    determineDataLimits: function() {
                        function a(t) {
                            return e ? t.xAxisID === r.id : t.yAxisID === r.id;
                        }
                        var r = this, l = r.options, s = r.chart, t = s.data.datasets, e = r.isHorizontal();
                        if (r.min = null, r.max = null, l.stacked) {
                            var d = {};
                            u.each(t, function(t, e) {
                                var n = s.getDatasetMeta(e);
                                void 0 === d[n.type] && (d[n.type] = {
                                    positiveValues: [],
                                    negativeValues: []
                                });
                                var i = d[n.type].positiveValues, o = d[n.type].negativeValues;
                                s.isDatasetVisible(e) && a(n) && u.each(t.data, function(t, e) {
                                    var a = +r.getRightValue(t);
                                    isNaN(a) || n.data[e].hidden || (i[e] = i[e] || 0, o[e] = o[e] || 0, l.relativePoints ? i[e] = 100 : a < 0 ? o[e] += a : i[e] += a);
                                });
                            }), u.each(d, function(t) {
                                var e = t.positiveValues.concat(t.negativeValues), a = u.min(e), n = u.max(e);
                                r.min = null === r.min ? a : Math.min(r.min, a), r.max = null === r.max ? n : Math.max(r.max, n);
                            });
                        } else u.each(t, function(t, e) {
                            var n = s.getDatasetMeta(e);
                            s.isDatasetVisible(e) && a(n) && u.each(t.data, function(t, e) {
                                var a = +r.getRightValue(t);
                                isNaN(a) || n.data[e].hidden || (null === r.min ? r.min = a : a < r.min && (r.min = a), 
                                null === r.max ? r.max = a : a > r.max && (r.max = a));
                            });
                        });
                        this.handleTickRangeOptions();
                    },
                    getTickLimit: function() {
                        var t, e = this.options.ticks;
                        if (this.isHorizontal()) t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.width / 50)); else {
                            var a = u.getValueOrDefault(e.fontSize, n.defaults.global.defaultFontSize);
                            t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.height / (2 * a)));
                        }
                        return t;
                    },
                    handleDirectionalChanges: function() {
                        this.isHorizontal() || this.ticks.reverse();
                    },
                    getLabelForIndex: function(t, e) {
                        return +this.getRightValue(this.chart.data.datasets[e].data[t]);
                    },
                    getPixelForValue: function(t) {
                        var e, a, n = this, i = n.paddingLeft, o = n.paddingBottom, r = n.start, l = +n.getRightValue(t), s = n.end - r;
                        return n.isHorizontal() ? (a = n.width - (i + n.paddingRight), e = n.left + a / s * (l - r), 
                        Math.round(e + i)) : (a = n.height - (n.paddingTop + o), e = n.bottom - o - a / s * (l - r), 
                        Math.round(e));
                    },
                    getValueForPixel: function(t) {
                        var e = this, a = e.isHorizontal(), n = e.paddingLeft, i = e.paddingBottom, o = a ? e.width - (n + e.paddingRight) : e.height - (e.paddingTop + i), r = (a ? t - e.left - n : e.bottom - i - t) / o;
                        return e.start + (e.end - e.start) * r;
                    },
                    getPixelForTick: function(t) {
                        return this.getPixelForValue(this.ticksAsNumbers[t]);
                    }
                });
                n.scaleService.registerScaleType("linear", e, t);
            };
        }, {} ],
        42: [ function(t, e, a) {
            e.exports = function(o) {
                var r = o.helpers, t = r.noop;
                o.LinearScaleBase = o.Scale.extend({
                    handleTickRangeOptions: function() {
                        var t = this, e = t.options.ticks;
                        if (e.beginAtZero) {
                            var a = r.sign(t.min), n = r.sign(t.max);
                            a < 0 && n < 0 ? t.max = 0 : 0 < a && 0 < n && (t.min = 0);
                        }
                        void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (t.min = Math.min(t.min, e.suggestedMin)), 
                        void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (t.max = Math.max(t.max, e.suggestedMax)), 
                        t.min === t.max && (t.max++, e.beginAtZero || t.min--);
                    },
                    getTickLimit: t,
                    handleDirectionalChanges: t,
                    buildTicks: function() {
                        var t = this, e = t.options.ticks, a = t.getTickLimit(), n = {
                            maxTicks: a = Math.max(2, a),
                            min: e.min,
                            max: e.max,
                            stepSize: r.getValueOrDefault(e.fixedStepSize, e.stepSize)
                        }, i = t.ticks = o.Ticks.generators.linear(n, t);
                        t.handleDirectionalChanges(), t.max = r.max(i), t.min = r.min(i), e.reverse ? (i.reverse(), 
                        t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);
                    },
                    convertTicksToLabels: function() {
                        var t = this;
                        t.ticksAsNumbers = t.ticks.slice(), t.zeroLineIndex = t.ticks.indexOf(0), o.Scale.prototype.convertTicksToLabels.call(t);
                    }
                });
            };
        }, {} ],
        43: [ function(t, e, a) {
            e.exports = function(i) {
                var c = i.helpers, t = {
                    position: "left",
                    ticks: {
                        callback: i.Ticks.formatters.logarithmic
                    }
                }, e = i.Scale.extend({
                    determineDataLimits: function() {
                        function a(t) {
                            return i ? t.xAxisID === o.id : t.yAxisID === o.id;
                        }
                        var o = this, r = o.options, t = r.ticks, l = o.chart, e = l.data.datasets, n = c.getValueOrDefault, i = o.isHorizontal();
                        if (o.min = null, o.max = null, o.minNotZero = null, r.stacked) {
                            var s = {};
                            c.each(e, function(t, e) {
                                var i = l.getDatasetMeta(e);
                                l.isDatasetVisible(e) && a(i) && (void 0 === s[i.type] && (s[i.type] = []), c.each(t.data, function(t, e) {
                                    var a = s[i.type], n = +o.getRightValue(t);
                                    isNaN(n) || i.data[e].hidden || (a[e] = a[e] || 0, r.relativePoints ? a[e] = 100 : a[e] += n);
                                }));
                            }), c.each(s, function(t) {
                                var e = c.min(t), a = c.max(t);
                                o.min = null === o.min ? e : Math.min(o.min, e), o.max = null === o.max ? a : Math.max(o.max, a);
                            });
                        } else c.each(e, function(t, e) {
                            var n = l.getDatasetMeta(e);
                            l.isDatasetVisible(e) && a(n) && c.each(t.data, function(t, e) {
                                var a = +o.getRightValue(t);
                                isNaN(a) || n.data[e].hidden || (null === o.min ? o.min = a : a < o.min && (o.min = a), 
                                null === o.max ? o.max = a : a > o.max && (o.max = a), 0 !== a && (null === o.minNotZero || a < o.minNotZero) && (o.minNotZero = a));
                            });
                        });
                        o.min = n(t.min, o.min), o.max = n(t.max, o.max), o.min === o.max && (0 !== o.min && null !== o.min ? (o.min = Math.pow(10, Math.floor(c.log10(o.min)) - 1), 
                        o.max = Math.pow(10, Math.floor(c.log10(o.max)) + 1)) : (o.min = 1, o.max = 10));
                    },
                    buildTicks: function() {
                        var t = this, e = t.options.ticks, a = {
                            min: e.min,
                            max: e.max
                        }, n = t.ticks = i.Ticks.generators.logarithmic(a, t);
                        t.isHorizontal() || n.reverse(), t.max = c.max(n), t.min = c.min(n), e.reverse ? (n.reverse(), 
                        t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);
                    },
                    convertTicksToLabels: function() {
                        this.tickValues = this.ticks.slice(), i.Scale.prototype.convertTicksToLabels.call(this);
                    },
                    getLabelForIndex: function(t, e) {
                        return +this.getRightValue(this.chart.data.datasets[e].data[t]);
                    },
                    getPixelForTick: function(t) {
                        return this.getPixelForValue(this.tickValues[t]);
                    },
                    getPixelForValue: function(t) {
                        var e, a, n, i = this, o = i.start, r = +i.getRightValue(t), l = i.paddingTop, s = i.paddingBottom, d = i.paddingLeft, u = i.options.ticks;
                        return i.isHorizontal() ? (n = c.log10(i.end) - c.log10(o), 0 === r ? a = i.left + d : (e = i.width - (d + i.paddingRight), 
                        a = i.left + e / n * (c.log10(r) - c.log10(o)), a += d)) : (e = i.height - (l + s), 
                        a = 0 !== o || u.reverse ? 0 === i.end && u.reverse ? (n = c.log10(i.start) - c.log10(i.minNotZero), 
                        r === i.end ? i.top + l : r === i.minNotZero ? i.top + l + .02 * e : i.top + l + .02 * e + .98 * e / n * (c.log10(r) - c.log10(i.minNotZero))) : (n = c.log10(i.end) - c.log10(o), 
                        e = i.height - (l + s), i.bottom - s - e / n * (c.log10(r) - c.log10(o))) : (n = c.log10(i.end) - c.log10(i.minNotZero), 
                        r === o ? i.bottom - s : r === i.minNotZero ? i.bottom - s - .02 * e : i.bottom - s - .02 * e - .98 * e / n * (c.log10(r) - c.log10(i.minNotZero)))), 
                        a;
                    },
                    getValueForPixel: function(t) {
                        var e, a = this, n = c.log10(a.end) - c.log10(a.start);
                        return a.isHorizontal() ? (e = a.width - (a.paddingLeft + a.paddingRight), a.start * Math.pow(10, (t - a.left - a.paddingLeft) * n / e)) : (e = a.height - (a.paddingTop + a.paddingBottom), 
                        Math.pow(10, (a.bottom - a.paddingBottom - t) * n / e) / a.start);
                    }
                });
                i.scaleService.registerScaleType("logarithmic", e, t);
            };
        }, {} ],
        44: [ function(t, e, a) {
            e.exports = function(e) {
                var C = e.helpers, w = e.defaults.global, t = {
                    display: !0,
                    animate: !0,
                    lineArc: !1,
                    position: "chartArea",
                    angleLines: {
                        display: !0,
                        color: "rgba(0, 0, 0, 0.1)",
                        lineWidth: 1
                    },
                    ticks: {
                        showLabelBackdrop: !0,
                        backdropColor: "rgba(255,255,255,0.75)",
                        backdropPaddingY: 2,
                        backdropPaddingX: 2,
                        callback: e.Ticks.formatters.linear
                    },
                    pointLabels: {
                        fontSize: 10,
                        callback: function(t) {
                            return t;
                        }
                    }
                }, a = e.LinearScaleBase.extend({
                    getValueCount: function() {
                        return this.chart.data.labels.length;
                    },
                    setDimensions: function() {
                        var t = this, e = t.options, a = e.ticks;
                        t.width = t.maxWidth, t.height = t.maxHeight, t.xCenter = Math.round(t.width / 2), 
                        t.yCenter = Math.round(t.height / 2);
                        var n = C.min([ t.height, t.width ]), i = C.getValueOrDefault(a.fontSize, w.defaultFontSize);
                        t.drawingArea = e.display ? n / 2 - (i / 2 + a.backdropPaddingY) : n / 2;
                    },
                    determineDataLimits: function() {
                        var i = this, a = i.chart;
                        i.min = null, i.max = null, C.each(a.data.datasets, function(t, e) {
                            if (a.isDatasetVisible(e)) {
                                var n = a.getDatasetMeta(e);
                                C.each(t.data, function(t, e) {
                                    var a = +i.getRightValue(t);
                                    isNaN(a) || n.data[e].hidden || (null === i.min ? i.min = a : a < i.min && (i.min = a), 
                                    null === i.max ? i.max = a : a > i.max && (i.max = a));
                                });
                            }
                        }), i.handleTickRangeOptions();
                    },
                    getTickLimit: function() {
                        var t = this.options.ticks, e = C.getValueOrDefault(t.fontSize, w.defaultFontSize);
                        return Math.min(t.maxTicksLimit ? t.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * e)));
                    },
                    convertTicksToLabels: function() {
                        var t = this;
                        e.LinearScaleBase.prototype.convertTicksToLabels.call(t), t.pointLabels = t.chart.data.labels.map(t.options.pointLabels.callback, t);
                    },
                    getLabelForIndex: function(t, e) {
                        return +this.getRightValue(this.chart.data.datasets[e].data[t]);
                    },
                    fit: function() {
                        var t, e, a, n, i, o, r, l, s, d, u, c, h = this.options.pointLabels, f = C.getValueOrDefault(h.fontSize, w.defaultFontSize), g = C.getValueOrDefault(h.fontStyle, w.defaultFontStyle), p = C.getValueOrDefault(h.fontFamily, w.defaultFontFamily), m = C.fontString(f, g, p), b = C.min([ this.height / 2 - f - 5, this.width / 2 ]), v = this.width, x = 0;
                        for (this.ctx.font = m, this.ctx.setFontSize(f), e = 0; e < this.getValueCount(); e++) {
                            t = this.getPointPosition(e, b), a = this.ctx.measureText(this.pointLabels[e] ? this.pointLabels[e] : "").width + 5;
                            var y = 360 * (this.getIndexAngle(e) + Math.PI / 2) / (2 * Math.PI) % 360;
                            0 === y || 180 === y ? (n = a / 2, t.x + n > v && (v = t.x + n, i = e), t.x - n < x && (x = t.x - n, 
                            r = e)) : y < 180 ? t.x + a > v && (v = t.x + a, i = e) : t.x - a < x && (x = t.x - a, 
                            r = e);
                        }
                        s = x, d = Math.ceil(v - this.width), o = this.getIndexAngle(i), l = this.getIndexAngle(r), 
                        u = d / Math.sin(o + Math.PI / 2), c = s / Math.sin(l + Math.PI / 2), u = C.isNumber(u) ? u : 0, 
                        c = C.isNumber(c) ? c : 0, this.drawingArea = Math.round(b - (c + u) / 2), this.setCenterPoint(c, u);
                    },
                    setCenterPoint: function(t, e) {
                        var a = this, n = a.width - e - a.drawingArea, i = t + a.drawingArea;
                        a.xCenter = Math.round((i + n) / 2 + a.left), a.yCenter = Math.round(a.height / 2 + a.top);
                    },
                    getIndexAngle: function(t) {
                        var e = 2 * Math.PI / this.getValueCount(), a = (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360;
                        return t * e - Math.PI / 2 + a;
                    },
                    getDistanceFromCenterForValue: function(t) {
                        var e = this;
                        if (null === t) return 0;
                        var a = e.drawingArea / (e.max - e.min);
                        return e.options.reverse ? (e.max - t) * a : (t - e.min) * a;
                    },
                    getPointPosition: function(t, e) {
                        var a = this.getIndexAngle(t);
                        return {
                            x: Math.round(Math.cos(a) * e) + this.xCenter,
                            y: Math.round(Math.sin(a) * e) + this.yCenter
                        };
                    },
                    getPointPositionForValue: function(t, e) {
                        return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
                    },
                    getBasePosition: function() {
                        var t = this.min, e = this.max;
                        return this.getPointPositionForValue(0, this.beginAtZero ? 0 : t < 0 && e < 0 ? e : 0 < t && 0 < e ? t : 0);
                    },
                    draw: function() {
                        var s = this, d = s.options, u = d.gridLines, c = d.ticks, t = d.angleLines, e = d.pointLabels, h = C.getValueOrDefault;
                        if (d.display) {
                            var f = s.ctx, g = h(c.fontSize, w.defaultFontSize), a = h(c.fontStyle, w.defaultFontStyle), n = h(c.fontFamily, w.defaultFontFamily), p = C.fontString(g, a, n);
                            if (C.each(s.ticks, function(t, e) {
                                if (0 < e || d.reverse) {
                                    var a = s.getDistanceFromCenterForValue(s.ticksAsNumbers[e]), n = s.yCenter - a;
                                    if (u.display && 0 !== e) if (f.setStrokeStyle(C.getValueAtIndexOrDefault(u.color, e - 1)), 
                                    f.setLineWidth(C.getValueAtIndexOrDefault(u.lineWidth, e - 1)), d.lineArc) f.beginPath(), 
                                    f.arc(s.xCenter, s.yCenter, a, 0, 2 * Math.PI), f.closePath(), f.stroke(); else {
                                        f.beginPath();
                                        for (var i = 0; i < s.getValueCount(); i++) {
                                            var o = s.getPointPosition(i, a);
                                            0 === i ? f.moveTo(o.x, o.y) : f.lineTo(o.x, o.y);
                                        }
                                        f.closePath(), f.stroke();
                                    }
                                    if (c.display) {
                                        var r = h(c.fontColor, w.defaultFontColor);
                                        if (f.font = p, f.setFontSize(g), c.showLabelBackdrop) {
                                            var l = f.measureText(t).width;
                                            f.setFillStyle(c.backdropColor), f.fillRect(s.xCenter - l / 2 - c.backdropPaddingX, n - g / 2 - c.backdropPaddingY, l + 2 * c.backdropPaddingX, g + 2 * c.backdropPaddingY);
                                        }
                                        f.textAlign = "center", f.textBaseline = "middle", f.setFillStyle(r), f.fillText(t, s.xCenter, n);
                                    }
                                }
                            }), !d.lineArc) {
                                f.setLineWidth(t.lineWidth), f.setStrokeStyle(t.color);
                                for (var i = s.getDistanceFromCenterForValue(d.reverse ? s.min : s.max), o = h(e.fontSize, w.defaultFontSize), r = h(e.fontStyle, w.defaultFontStyle), l = h(e.fontFamily, w.defaultFontFamily), m = C.fontString(o, r, l), b = s.getValueCount() - 1; 0 <= b; b--) {
                                    if (t.display) {
                                        var v = s.getPointPosition(b, i);
                                        f.beginPath(), f.moveTo(s.xCenter, s.yCenter), f.lineTo(v.x, v.y), f.stroke(), f.closePath();
                                    }
                                    var x = s.getPointPosition(b, i + 5), y = h(e.fontColor, w.defaultFontColor);
                                    f.font = m, f.setFontSize(o), f.setFillStyle(y);
                                    var k = s.pointLabels, S = 360 * (this.getIndexAngle(b) + Math.PI / 2) / (2 * Math.PI) % 360;
                                    f.textAlign = 0 === S || 180 === S ? "center" : S < 180 ? "left" : "right", f.textBaseline = 90 === S || 270 === S ? "middle" : 270 < S || S < 90 ? "bottom" : "top", 
                                    f.fillText(k[b] ? k[b] : "", x.x, x.y);
                                }
                            }
                        }
                    }
                });
                e.scaleService.registerScaleType("radialLinear", a, t);
            };
        }, {} ]
    }, {}, [ 1 ])(1);
});